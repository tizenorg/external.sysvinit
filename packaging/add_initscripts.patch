diff -ruN sysvinit-2.87dsf/initscripts/doc/README.Debian sysvinit/initscripts/doc/README.Debian
--- sysvinit-2.87dsf/initscripts/doc/README.Debian	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/doc/README.Debian	2011-07-26 02:05:43.385000852 +0900
@@ -0,0 +1,54 @@
+tmpfs
+-----
+
+Tmpfs can be used as virtual memory filesystem. glibc 2.2 and above
+expects a tmpfs to be mounted at /dev/shm for POSIX shared memory,
+this is done automatically by /etc/init.d/mountdevsubfs.sh early in
+the boot process. You can limit tmpfs max size by setting the
+SHM_SIZE variable to a desired size in the /etc/default/tmpfs file
+to prevent tmpfs from using up all system memory.
+
+A tmpfs can also be mounted over /var/run/ and /var/lock/. This can
+be achieved by setting the RAMRUN and RAMLOCK variables to "yes" in
+the /etc/default/rcS file. A size limit for the tmpfs filesystem
+mounted over /var/run/ and /var/lock/ can be set via the RUN_SIZE
+and LOCK_SIZE variables in the /etc/default/tmpfs file.
+
+If TMPFS_SIZE is set in /etc/default/tmpfs, it will be used as the
+default value for SHM_SIZE, RUN_SIZE and LOCK_SIZE. Otherwise, kernel
+defaults are used.
+
+
+sendsigs process omission interface
+-----------------------------------
+
+Since initscripts package version 2.86.ds1-48, /etc/init.d/sendsigs
+is able to omit processes from being killed by killall5(8). Process
+id's listed in /var/run/sendsigs.omit, /lib/init/rw/sendsigs.omit or
+any file in the /lib/init/rw/sendsigs.omit.d/ directory will be
+omitted by sendsigs.
+
+The recommended practise for adding a process id for omission is to
+create a file in /lib/init/rw/sendsigs.omit.d/<package name>
+containing the process id that is to be omitted by sendsigs.
+
+This feature is only to be used for processes that need to be
+running when remote file systems are umounted, and that have
+current working directory set to a directory in the root file system.
+
+
+/sys in /etc/fstab
+------------------
+
+If the mount point /sys/ has an entry in /etc/fstab (which is not
+required, it will be mounted in any case), the entry must be:
+
+  sysfs /sys sysfs rw,nosuid,nodev,noexec 0 0
+
+The reason is that the entry in fstab needs to match the entry
+generated by the mountkernfs.sh and mtab.sh scripts.  If it does not,
+the system will complain with this message during boot:
+
+  Will now mount local filesystems:mount: /sys already mounted or /sys busy
+  mount: according to mtab, sysfs is already mounted on /sys
+    failed
diff -ruN sysvinit-2.87dsf/initscripts/etc/default/bootlogd sysvinit/initscripts/etc/default/bootlogd
--- sysvinit-2.87dsf/initscripts/etc/default/bootlogd	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/default/bootlogd	2011-07-26 02:05:43.386000853 +0900
@@ -0,0 +1,2 @@
+# Run bootlogd at startup ?
+BOOTLOGD_ENABLE=No
diff -ruN sysvinit-2.87dsf/initscripts/etc/default/devpts sysvinit/initscripts/etc/default/devpts
--- sysvinit-2.87dsf/initscripts/etc/default/devpts	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/default/devpts	2011-07-26 02:05:43.386000853 +0900
@@ -0,0 +1,5 @@
+# GID of the `tty' group
+TTYGRP=5
+
+# Set to 600 to have `mesg n' be the default
+TTYMODE=620
diff -ruN sysvinit-2.87dsf/initscripts/etc/default/halt sysvinit/initscripts/etc/default/halt
--- sysvinit-2.87dsf/initscripts/etc/default/halt	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/default/halt	2011-07-26 02:05:43.386000853 +0900
@@ -0,0 +1,2 @@
+# Default behaviour of shutdown -h / halt. Set to "halt" or "poweroff".
+HALT=poweroff
diff -ruN sysvinit-2.87dsf/initscripts/etc/default/tmpfs sysvinit/initscripts/etc/default/tmpfs
--- sysvinit-2.87dsf/initscripts/etc/default/tmpfs	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/default/tmpfs	2011-07-26 02:05:43.386000853 +0900
@@ -0,0 +1,6 @@
+# SHM_SIZE sets the maximum size (in bytes) that the /dev/shm tmpfs can use.
+# If this is not set then the size defaults to the value of TMPFS_SIZE
+# if that is set; otherwise to the kernel's default.
+#
+# The size will be rounded down to a multiple of the page size, 4096 bytes.
+SHM_SIZE=
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/bootlogd sysvinit/initscripts/etc/init.d/bootlogd
--- sysvinit-2.87dsf/initscripts/etc/init.d/bootlogd	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/bootlogd	2011-07-26 02:05:43.386000853 +0900
@@ -0,0 +1,96 @@
+#! /bin/sh
+### BEGIN INIT INFO
+# Provides:          bootlogd
+# Required-Start:    mountdevsubfs
+# X-Start-Before:    hostname keymap keyboard-setup procps pcmcia hwclock hwclockfirst hdparm hibernate-cleanup lvm2
+# Required-Stop:
+# Default-Start:     S
+# Default-Stop:
+# Short-Description: Start or stop bootlogd.
+# Description:       Starts or stops the bootlogd log program
+#                    which logs boot messages.
+### END INIT INFO
+
+PATH=/sbin:/bin  # No remote fs at start
+DAEMON=/sbin/bootlogd
+[ -x "$DAEMON" ] || exit 0
+NAME=bootlogd
+DESC="boot logger"
+BOOTLOGD_OPTS="-r -c"
+[ -r /etc/default/bootlogd ] && . /etc/default/bootlogd
+. /lib/init/vars.sh
+
+. /lib/lsb/init-functions
+
+# Because bootlogd is broken on some systems, we take the special measure
+# of requiring it to be enabled by setting an environment variable.
+case "$BOOTLOGD_ENABLE" in
+  [Nn]*)
+	exit 0
+	;;
+esac
+
+# Previously this script was symlinked as "stop-bootlogd" which, when run
+# with the "start" argument, should stop bootlogd.  Now stop-bootlogd is
+# a distinct script, but for backward compatibility this script continues
+# to implement the old behavior.
+SCRIPTNAME=${0##*/}
+SCRIPTNAME=${SCRIPTNAME#[SK]??}
+ACTION="$1"
+case "$0" in
+  *stop-bootlog*)
+	[ "$ACTION" = start ] && ACTION=stop
+	;;
+esac
+
+case "$ACTION" in
+  start)
+  	# PATH is set above
+	log_daemon_msg "Starting $DESC" "$NAME"
+	if [ -d /proc/1/. ]
+	then
+		umask 027
+		start-stop-daemon --start --quiet --exec $DAEMON -- \
+			$BOOTLOGD_OPTS
+		ES=$?
+	else
+		$DAEMON $BOOTLOGD_OPTS
+		ES=$?
+	fi
+	log_end_msg $ES
+	;;
+  stop)
+	PATH=/bin:/sbin:/usr/bin:/usr/sbin
+	log_daemon_msg "Stopping $DESC" "$NAME"
+	start-stop-daemon --oknodo --stop --quiet --exec $DAEMON
+	ES=$?
+	sleep 1
+	log_end_msg $ES
+	if [ -f /var/log/boot ] && [ -f /var/log/boot~ ]
+	then
+		[ "$VERBOSE" = no ] || log_action_begin_msg "Moving boot log file"
+		# bootlogd writes to boot, making backup at boot~
+		cd /var/log && {
+			chgrp adm boot || :
+			savelog -q -p -c 5 boot \
+			&& mv boot.0 boot \
+			&& mv boot~ boot.0
+		}
+		ES=$?
+		[ "$VERBOSE" = no ] || log_action_end_msg $ES
+	fi
+	;;
+  restart|force-reload)
+ 	/etc/init.d/bootlogd stop
+ 	/etc/init.d/bootlogd start
+	;;
+  status)
+	status_of_proc "$DAEMON" "$NAME" && exit 0 || exit $?
+	;;
+  *)
+	echo "Usage: $SCRIPTNAME {start|stop|restart|force-reload|status}" >&2
+	exit 3
+	;;
+esac
+
+:
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/bootlogs sysvinit/initscripts/etc/init.d/bootlogs
--- sysvinit-2.87dsf/initscripts/etc/init.d/bootlogs	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/bootlogs	2011-07-26 02:05:43.387000850 +0900
@@ -0,0 +1,76 @@
+#!/bin/sh
+### BEGIN INIT INFO
+# Provides:          bootlogs
+# Required-Start:    hostname $local_fs
+# Required-Stop:
+# Should-Start:      gdm kdm xdm ldm sdm
+# Default-Start:     1 2 3 4 5
+# Default-Stop:
+# Short-Description: Log file handling to be done during bootup.
+# Description:       Various things that don't need to be done particularly
+#                    early in the boot, just before getty is run.
+### END INIT INFO
+
+PATH=/sbin:/usr/sbin:/bin:/usr/bin
+[ "$DELAYLOGIN" ] || DELAYLOGIN=yes
+. /lib/init/vars.sh
+
+do_start () {
+	# Update motd
+	uname -snrvm > /var/run/motd
+	[ -f /etc/motd.tail ] && cat /etc/motd.tail >> /var/run/motd
+
+	# Save kernel messages in /var/log/dmesg
+	if which dmesg >/dev/null 2>&1
+	then
+		[ -f /var/log/dmesg ] && savelog -q -p -c 5 /var/log/dmesg
+		dmesg -s 524288 > /var/log/dmesg
+		chgrp adm /var/log/dmesg || :
+	elif [ -c /dev/klog ]
+	then
+		[ -f /var/log/dmesg ] && savelog -q -p -c 5 /var/log/dmesg
+		dd if=/dev/klog of=/var/log/dmesg &
+		sleep 1
+		kill $!
+		[ -f /var/log/dmesg ] && { chgrp adm /var/log/dmesg || : ; }
+	fi
+
+	#
+	#	Save udev log in /var/log/udev
+	#
+	if [ -e /dev/.udev.log ]
+	then
+		mv -f /dev/.udev.log /var/log/udev
+	fi
+}
+
+do_status () {
+	if [ -f /var/run/motd ] && [ ! -f /dev/.udev.log ] ; then
+		return 0
+	else
+		return 4
+	fi
+}
+
+case "$1" in
+  start|"")
+	do_start
+	;;
+  restart|reload|force-reload)
+	echo "Error: argument '$1' not supported" >&2
+	exit 3
+	;;
+  stop)
+	# No-op
+	;;
+  status)
+	do_status
+	exit $?
+	;;
+  *)
+	echo "Usage: bootlogs [start|stop|status]" >&2
+	exit 3
+	;;
+esac
+
+:
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/bootmisc.sh sysvinit/initscripts/etc/init.d/bootmisc.sh
--- sysvinit-2.87dsf/initscripts/etc/init.d/bootmisc.sh	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/bootmisc.sh	2011-07-26 02:05:43.386000853 +0900
@@ -0,0 +1,65 @@
+#!/bin/sh
+### BEGIN INIT INFO
+# Provides:          bootmisc
+# Required-Start:    $remote_fs
+# Required-Stop:
+# Should-Start:      udev
+# Default-Start:     S
+# Default-Stop:
+# Short-Description: Miscellaneous things to be done during bootup.
+# Description:       Some cleanup.  Note, it need to run after mountnfs-bootclean.sh.
+### END INIT INFO
+
+PATH=/sbin:/usr/sbin:/bin:/usr/bin
+[ "$DELAYLOGIN" ] || DELAYLOGIN=yes
+. /lib/init/vars.sh
+
+do_start () {
+	#
+	# If login delaying is enabled then create the flag file
+	# which prevents logins before startup is complete
+	#
+	case "$DELAYLOGIN" in
+	  Y*|y*)
+		echo "System bootup in progress - please wait" > /var/lib/initscripts/nologin
+		;;
+	esac
+
+	# Create /var/run/utmp so we can login.
+	: > /var/run/utmp
+	if grep -q ^utmp: /etc/group
+	then
+		chmod 664 /var/run/utmp
+		chgrp utmp /var/run/utmp
+	fi
+
+	# Set pseudo-terminal access permissions.
+	if [ ! -e /dev/.devfsd ] && [ ! -e /dev/.udev ] && [ -c /dev/ttyp0 ]
+	then
+		chmod -f 666 /dev/tty[p-za-e][0-9a-f]
+		chown -f root:tty /dev/tty[p-za-e][0-9a-f]
+	fi
+
+	# Remove bootclean's flag files.
+	# Don't run bootclean again after this!
+	rm -f /tmp/.clean /var/run/.clean /var/lock/.clean
+}
+
+case "$1" in
+  start|"")
+	do_start
+	;;
+  restart|reload|force-reload)
+	echo "Error: argument '$1' not supported" >&2
+	exit 3
+	;;
+  stop)
+	# No-op
+	;;
+  *)
+	echo "Usage: bootmisc.sh [start|stop]" >&2
+	exit 3
+	;;
+esac
+
+:
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/checkfs.sh sysvinit/initscripts/etc/init.d/checkfs.sh
--- sysvinit-2.87dsf/initscripts/etc/init.d/checkfs.sh	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/checkfs.sh	2011-07-26 02:05:43.386000853 +0900
@@ -0,0 +1,156 @@
+#! /bin/sh
+### BEGIN INIT INFO
+# Provides:          checkfs
+# Required-Start:    checkroot
+# Required-Stop:
+# Should-Start:      mtab
+# Default-Start:     S
+# Default-Stop:
+# X-Interactive:     true
+# Short-Description: Check all filesystems.
+### END INIT INFO
+
+## We don't need this on SLP platform
+[ -e /etc/init.d/.slp ] && exit 0
+
+# Include /usr/bin in path to find on_ac_power if /usr/ is on the root
+# partition.
+PATH=/sbin:/bin:/usr/bin
+FSCK_LOGFILE=/var/log/fsck/checkfs
+[ "$FSCKFIX" ] || FSCKFIX=no
+. /lib/init/vars.sh
+
+. /lib/lsb/init-functions
+. /lib/init/splash-functions-base
+. /lib/init/usplash-fsck-functions.sh
+
+do_start () {
+	# See if we're on AC Power.  If not, we're not gonna run our
+	# check.  If on_ac_power (in /usr/) is unavailable, behave as
+	# before and check all file systems needing it.
+
+# Disabled AC power check until fsck can be told to only check the
+# file system if it is corrupt when running on battery. (bug #526398)
+#	if which on_ac_power >/dev/null 2>&1
+#	then
+#		on_ac_power >/dev/null 2>&1
+#		if [ $? -eq 1 ]
+#		then
+#			[ "$VERBOSE" = no ] || log_success_msg "Running on battery power, so skipping file system check."
+#			BAT=yes
+#		fi
+#	fi
+	BAT=""
+	fscheck="yes"
+
+	if [ -f /fastboot ] || grep -s -w -i "fastboot" /proc/cmdline
+	then
+		[ "$fscheck" = yes ] && log_warning_msg "Fast boot enabled, so skipping file system check."
+		fscheck=no
+	fi
+
+	#
+	# Check the rest of the file systems.
+	#
+	if [ "$fscheck" = yes ] && [ ! "$BAT" ] && [ "$FSCKTYPES" != "none" ]
+	then
+		if [ -f /forcefsck ] || grep -s -w -i "forcefsck" /proc/cmdline
+		then
+			force="-f"
+		else
+			force=""
+		fi
+		if [ "$FSCKFIX" = yes ]
+		then
+			fix="-y"
+		else
+			fix="-a"
+		fi
+		spinner="-C"
+		case "$TERM" in
+		  dumb|network|unknown|"")
+			spinner=""
+			;;
+		esac
+		[ "$(uname -m)" = s390 ] && spinner=""  # This should go away
+		FSCKTYPES_OPT=""
+		[ "$FSCKTYPES" ] && FSCKTYPES_OPT="-t $FSCKTYPES"
+		handle_failed_fsck() {
+			log_failure_msg "File system check failed. 
+A log is being saved in ${FSCK_LOGFILE} if that location is writable. 
+Please repair the file system manually."
+			log_warning_msg "A maintenance shell will now be started. 
+CONTROL-D will terminate this shell and resume system boot."
+			# Start a single user shell on the console
+			if ! sulogin $CONSOLE
+			then
+				log_failure_msg "Attempt to start maintenance shell failed. 
+Continuing with system boot in 5 seconds."
+				sleep 5
+			fi
+		}
+		if [ "$VERBOSE" = no ]
+		then
+			log_action_begin_msg "Checking file systems"
+			if usplash_running; then
+			    PROGRESS_FILE=`mktemp` || exit 1
+			    set -m
+			    logsave -s $FSCK_LOGFILE fsck -C3 -R -A $fix $force $FSCKTYPES_OPT >/dev/console 2>&1 3>$PROGRESS_FILE &
+			    set +m
+			    usplash_progress "$PROGRESS_FILE"
+			    rm -f $PROGRESS_FILE
+			else
+			    splash_start_indefinite
+			    logsave -s $FSCK_LOGFILE fsck $spinner -R -A $fix $force $FSCKTYPES_OPT
+			    FSCKCODE=$?
+			    splash_stop_indefinite
+			fi
+
+			if [ "$FSCKCODE" -gt 1 ]
+			then
+				log_action_end_msg 1 "code $FSCKCODE"
+				handle_failed_fsck
+			else
+				log_action_end_msg 0
+			fi
+		else
+			if [ "$FSCKTYPES" ]
+			then
+				log_action_msg "Will now check all file systems of types $FSCKTYPES"
+			else
+				log_action_msg "Will now check all file systems"
+			fi
+			splash_start_indefinite
+			logsave -s $FSCK_LOGFILE fsck $spinner -V -R -A $fix $force $FSCKTYPES_OPT
+			FSCKCODE=$?
+			splash_stop_indefinite
+			if [ "$FSCKCODE" -gt 1 ]
+			then
+				handle_failed_fsck
+			else
+				log_success_msg "Done checking file systems. 
+A log is being saved in ${FSCK_LOGFILE} if that location is writable."
+			fi
+		fi
+	fi
+	rm -f /fastboot /forcefsck 2>/dev/null
+}
+
+case "$1" in
+  start|"")
+	do_start
+	;;
+  restart|reload|force-reload)
+	echo "Error: argument '$1' not supported" >&2
+	exit 3
+	;;
+  stop)
+	# No-op
+	;;
+  *)
+	echo "Usage: checkfs.sh [start|stop]" >&2
+	exit 3
+	;;
+esac
+
+:
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/checkroot.sh sysvinit/initscripts/etc/init.d/checkroot.sh
--- sysvinit-2.87dsf/initscripts/etc/init.d/checkroot.sh	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/checkroot.sh	2011-07-26 02:05:43.387000850 +0900
@@ -0,0 +1,447 @@
+#! /bin/sh
+### BEGIN INIT INFO
+# Provides:          checkroot
+# Required-Start:    mountdevsubfs hostname
+# Required-Stop:     
+# Should-Start:      keymap hwclockfirst hdparm bootlogd
+# Should-stop:
+# Default-Start:     S
+# Default-Stop:
+# X-Interactive:     true
+# Short-Description: Check to root file system.
+### END INIT INFO
+
+## We don't need this on SLP platform
+[ -e /etc/init.d/.slp ] && exit 0
+
+# Include /usr/bin in path to find on_ac_power if /usr/ is on the root
+# partition.
+PATH=/sbin:/bin:/usr/bin
+FSCK_LOGFILE=/var/log/fsck/checkroot
+[ "$FSCKFIX" ] || FSCKFIX=no
+[ "$SULOGIN" ] || SULOGIN=no
+. /lib/init/vars.sh
+
+. /lib/lsb/init-functions
+. /lib/init/mount-functions.sh
+. /lib/init/splash-functions-base
+. /lib/init/usplash-fsck-functions.sh
+
+do_start () {
+	#
+	# Set SULOGIN in /etc/default/rcS to yes if you want a sulogin to
+	# be spawned from this script *before anything else* with a timeout,
+	# like sysv does.
+	#
+	[ "$SULOGIN" = yes ] && sulogin -t 30 $CONSOLE
+
+	KERNEL="$(uname -s)"
+	MACHINE="$(uname -m)"
+
+	#
+	# Read /etc/fstab, looking for:
+	# 1) The root filesystem, resolving LABEL=*|UUID=* entries to the
+	# 	device node,
+	# 2) Swap that is on a md device or a file that may be on a md 
+	# 	device,
+	# 3) The mount parameters for a devfs filesystem.
+	#
+
+	exec 9<&0 </etc/fstab
+
+	fstabroot=/dev/root
+	rootdev=none
+	roottype=none
+	rootopts=defaults
+	rootmode=rw
+	rootcheck=no
+	swap_on_lv=no
+	swap_on_file=no
+	devfs=
+
+	while read DEV MTPT FSTYPE OPTS DUMP PASS JUNK
+	do
+		case "$DEV" in
+		  ""|\#*)
+			continue;
+			;;
+		  /dev/mapper/*)
+			[ "$FSTYPE" = "swap" ] && swap_on_lv=yes
+			;;
+		  /dev/*)
+			;;
+		  LABEL=*|UUID=*)
+			if [ "$MTPT" = "/" ] && [ -x /sbin/findfs ]
+			then
+				DEV="$(findfs "$DEV")"
+			fi
+			;;
+		  /*)
+			[ "$FSTYPE" = "swap" ] && swap_on_file=yes
+			;;
+		  *)
+			# Devfs definition ?
+			if [ "$FSTYPE" = "devfs" ] && [ "$MTPT" = "/dev" ] && mountpoint -q /dev
+			then
+				devfs="-t $FSTYPE $DEV $MTPT"
+			fi
+			;;
+		esac
+		[ "$MTPT" != "/" ] && continue
+		rootdev="$DEV"
+		fstabroot="$DEV"
+		rootopts="$OPTS"
+		roottype="$FSTYPE"
+		( [ "$PASS" != 0 ] && [ "$PASS" != "" ]   ) && rootcheck=yes
+		( [ "$FSTYPE" = "nfs" ] || [ "$FSTYPE" = "nfs4" ] ) && rootcheck=no
+		case "$OPTS" in
+		  ro|ro,*|*,ro|*,ro,*)
+			rootmode=ro
+			;;
+		esac
+	done
+
+	exec 0<&9 9<&-
+
+	#
+	# Activate the swap device(s) in /etc/fstab. This needs to be done
+	# before fsck, since fsck can be quite memory-hungry.
+	#
+	ENABLE_SWAP=no
+	case "$KERNEL" in
+	  Linux)
+	  	if [ "$NOSWAP" = yes ]
+		then
+			[ "$VERBOSE" = no ] || log_warning_msg "Not activating swap as requested via bootoption noswap."
+			ENABLE_SWAP=no
+		else
+			if [ "$swap_on_lv" = yes ]
+			then
+				[ "$VERBOSE" = no ] || log_warning_msg "Not activating swap on logical volume."
+			elif [ "$swap_on_file" = yes ]
+			then
+				[ "$VERBOSE" = no ] || log_warning_msg "Not activating swap on swapfile."
+			else
+				ENABLE_SWAP=yes
+			fi
+		fi
+		;;
+	  *)
+		ENABLE_SWAP=yes
+		;;
+	esac
+	if [ "$ENABLE_SWAP" = yes ]
+	then
+		if [ "$VERBOSE" = no ]
+		then
+			log_action_begin_msg "Activating swap"
+			swapon -a -e >/dev/null 2>&1
+			log_action_end_msg $?
+		else
+			log_daemon_msg "Activating swap"
+			swapon -a -v
+			log_end_msg $?
+		fi
+	fi
+
+	#
+	# Does the root device in /etc/fstab match with the actual device ?
+	# If not we try to use the /dev/root alias device, and if that
+	# fails we create a temporary node in /lib/init/rw.
+	#
+	if [ "$rootcheck" = yes ]
+	then
+		ddev="$(mountpoint -qx $rootdev)"
+		rdev="$(mountpoint -d /)"
+		if [ "$ddev" != "$rdev" ] && [ "$ddev" != "4:0" ]
+		then
+			if [ "$(mountpoint -qx /dev/root)" = "4:0" ]
+			then
+				rootdev=/dev/root
+			else
+				if \
+					rm -f /lib/init/rw/rootdev \
+					&& mknod -m 600 /lib/init/rw/rootdev b ${rdev%:*} ${rdev#*:} \
+					&& [ -e /lib/init/rw/rootdev ]
+				then
+					rootdev=/lib/init/rw/rootdev
+				else
+					rootfatal=yes
+				fi
+			fi
+		fi
+	fi
+
+	#
+	# Bother, said Pooh.
+	#
+	if [ "$rootfatal" = yes ]
+	then
+		log_failure_msg "The device node $rootdev for the root filesystem is missing or incorrect 
+or there is no entry for the root filesystem listed in /etc/fstab. 
+The system is also unable to create a temporary node in /lib/init/rw. 
+This means you have to fix the problem manually."
+		log_warning_msg "A maintenance shell will now be started. 
+CONTROL-D will terminate this shell and restart the system."
+		# Start a single user shell on the console
+		if ! sulogin $CONSOLE
+		then
+			log_failure_msg "Attempt to start maintenance shell failed. 
+Will restart in 5 seconds."
+			sleep 5
+		fi
+		[ "$VERBOSE" = no ] || log_action_msg "Will now restart"
+		reboot -f
+	fi
+
+	# See if we're on AC Power.  If not, we're not gonna run our
+	# check.  If on_ac_power (in /usr/) is unavailable, behave as
+	# before and check all file systems needing it.
+# Disabled AC power check until fsck can be told to only check the
+# file system if it is corrupt when running on battery. (bug #526398)
+#	if which on_ac_power >/dev/null 2>&1 && [ "$rootcheck" = yes ]
+#	then
+#		on_ac_power >/dev/null 2>&1
+#		if [ "$?" -eq 1 ]
+#		then
+#			log_warning_msg "On battery power, so skipping file system check."
+#			rootcheck=no
+#		fi
+#	fi
+
+	#
+	# See if we want to check the root file system.
+	#
+	FSCKCODE=0
+	if [ -f /fastboot ] || grep -s -w -i "fastboot" /proc/cmdline
+	then
+		[ "$rootcheck" = yes ] && log_warning_msg "Fast boot enabled, so skipping root file system check."
+		rootcheck=no
+	fi
+
+	if [ "$rootcheck" = yes ]
+	then
+		#
+		# Ensure that root is quiescent and read-only before fsck'ing.
+		#
+		# mount -n -o remount,ro / would be the correct syntax but
+		# mount can get confused when there is a "bind" mount defined
+		# in fstab that bind-mounts "/" somewhere else.
+		#
+		# So we use mount -n -o remount,ro $rootdev / but that can
+		# fail on older kernels on sparc64/alpha architectures due
+		# to a bug in sys_mount().
+		#
+		# As a compromise we try both.
+		#
+		if \
+			! mount    -n -o remount,ro              $rootdev /              \
+			&& ! mount -n -o remount,ro -t dummytype $rootdev /  2>/dev/null \
+			&& ! mount -n -o remount,ro                       /  2>/dev/null
+		then
+			log_failure_msg "Cannot check root file system because it is not mounted read-only."
+			rootcheck=no
+		fi
+	fi
+
+	#
+	# The actual checking is done here.
+	#
+	if [ "$rootcheck" = yes ]
+	then
+		if [ -f /forcefsck ] || grep -s -w -i "forcefsck" /proc/cmdline
+		then
+			force="-f"
+		else
+			force=""
+		fi
+
+		if [ "$FSCKFIX" = yes ]
+		then
+			fix="-y"
+		else
+			fix="-a"
+		fi
+
+		spinner="-C"
+		case "$TERM" in
+		  dumb|network|unknown|"")
+			spinner="" ;;
+		esac
+		# This Linux/s390 special case should go away.
+		if [ "${KERNEL}:${MACHINE}" = Linux:s390 ]
+		then
+			spinner=""
+		fi
+		
+		if [ "$VERBOSE" = no ]
+		then
+			log_action_begin_msg "Checking root file system"
+			if [ "$roottype" = "ext2" -o "$roottype" = "ext3" -o "$roottype" = "ext4" ] && usplash_running; then
+			    PROGRESS_FILE=`mktemp -p /lib/init/rw` || PROGRESS_FILE=/lib/init/rw/checkroot_fsck
+			    set -m
+			    logsave -s $FSCK_LOGFILE fsck -C3 $force $fix -t $roottype $rootdev >/dev/console 2>&1 3>$PROGRESS_FILE &
+			    set +m
+			    usplash_progress "$PROGRESS_FILE"
+			    rm -f $PROGRESS_FILE
+			else
+			    splash_start_indefinite
+			    logsave -s $FSCK_LOGFILE fsck $spinner $force $fix -t $roottype $rootdev
+			    FSCKCODE=$?
+			    splash_stop_indefinite
+			fi
+			if [ "$FSCKCODE" = 0 ]
+			then
+				log_action_end_msg 0
+			else
+				log_action_end_msg 1 "code $FSCKCODE"
+			fi
+		else
+			splash_start_indefinite
+			log_daemon_msg "Will now check root file system"
+			logsave -s $FSCK_LOGFILE fsck $spinner $force $fix -V -t $roottype $rootdev
+			FSCKCODE=$?
+			log_end_msg $FSCKCODE
+			splash_stop_indefinite
+		fi
+	fi
+
+	#
+	# If there was a failure, drop into single-user mode.
+	#
+	# NOTE: "failure" is defined as exiting with a return code of
+	# 4 or larger. A return code of 1 indicates that file system
+	# errors were corrected but that the boot may proceed. A return
+	# code of 2 or 3 indicates that the system should immediately reboot.
+	#
+	if [ "$FSCKCODE" -gt 3 ]
+	then
+		# Surprise! Re-directing from a HERE document (as in "cat << EOF")
+		# does not work because the root is currently read-only.
+		log_failure_msg "An automatic file system check (fsck) of the root filesystem failed. 
+A manual fsck must be performed, then the system restarted. 
+The fsck should be performed in maintenance mode with the 
+root filesystem mounted in read-only mode."
+		log_warning_msg "The root filesystem is currently mounted in read-only mode. 
+A maintenance shell will now be started. 
+After performing system maintenance, press CONTROL-D 
+to terminate the maintenance shell and restart the system."
+		# Start a single user shell on the console
+		if ! sulogin $CONSOLE
+		then
+			log_failure_msg "Attempt to start maintenance shell failed. 
+Will restart in 5 seconds."
+			sleep 5
+		fi
+		[ "$VERBOSE" = no ] || log_action_msg "Will now restart"
+		reboot -f
+	elif [ "$FSCKCODE" -gt 1 ]
+	then
+		log_failure_msg "The file system check corrected errors on the root partition 
+but requested that the system be restarted."
+		log_warning_msg "The system will be restarted in 5 seconds."
+		sleep 5
+		[ "$VERBOSE" = no ] || log_action_msg "Will now restart"
+		reboot -f
+	fi
+
+	#
+	# Remount root to final mode (rw or ro).
+	#
+	# See the comments above at the previous "mount -o remount"
+	# for an explanation why we try this twice.
+	#
+	if ! mount -n -o remount,$rootopts,$rootmode $fstabroot / 2>/dev/null
+	then
+		mount -n -o remount,$rootopts,$rootmode /
+	fi
+
+	#
+	# We only create/modify /etc/mtab if the location where it is
+	# stored is writable. If /etc/mtab is a symlink into /proc/
+	# then it is not writable.
+	#
+	INIT_MTAB_FILE=no
+	MTAB_PATH="$(readlink -f /etc/mtab || :)"
+	case "$MTAB_PATH" in
+	  /proc/*)
+		;;
+	  /*)
+		if touch "$MTAB_PATH" >/dev/null 2>&1
+		then
+			:> "$MTAB_PATH"
+			rm -f ${MTAB_PATH}~
+			INIT_MTAB_FILE=yes
+		fi
+		;;
+	  "")
+		[ -L /etc/mtab ] && MTAB_PATH="$(readlink /etc/mtab)"
+		if [ "$MTAB_PATH" ]
+		then
+			log_failure_msg "Cannot initialize ${MTAB_PATH}."
+		else
+			log_failure_msg "Cannot initialize /etc/mtab."
+		fi
+		;;
+	  *)
+		log_failure_msg "Illegal mtab location '${MTAB_PATH}'."
+		;;
+	esac
+
+	if [ "$INIT_MTAB_FILE" = yes ]
+	then
+		[ "$roottype" != none ] &&
+			mount -f -o $rootopts -t $roottype $fstabroot /
+		[ "$devfs" ] && mount -f $devfs
+	fi
+
+	#
+	# Remove /lib/init/rw/rootdev if we created it.
+	#
+	rm -f /lib/init/rw/rootdev
+}
+
+do_status () {
+	# If / is read-write or swap is enabled, this script have done
+	# its job.
+	rootrw=false
+	swapon=false
+	if [ -f /etc/mtab ] ; then
+	    if grep " / " /etc/mtab |grep -q rw ; then
+		rootrw=true
+	    fi
+	fi
+	if [ -f /proc/swaps ] ; then
+	    if [ "$(cat /proc/swaps |grep -v ^Filename)" ] ; then
+		swapon=true
+	    fi
+	fi
+	if [ true = "$rootrw" ] || [ true = "$swapon" ] ; then
+		return 0
+	else
+		return 4
+	fi
+}
+
+case "$1" in
+  start|"")
+	do_start
+	;;
+  restart|reload|force-reload)
+	echo "Error: argument '$1' not supported" >&2
+	exit 3
+	;;
+  stop)
+	# No-op
+	;;
+  status)
+	do_status
+	exit $?
+	;;
+  *)
+	echo "Usage: checkroot.sh [start|stop]" >&2
+	exit 3
+	;;
+esac
+
+:
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/halt sysvinit/initscripts/etc/init.d/halt
--- sysvinit-2.87dsf/initscripts/etc/init.d/halt	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/halt	2011-07-26 02:05:43.386000853 +0900
@@ -0,0 +1,83 @@
+#! /bin/sh
+### BEGIN INIT INFO
+# Provides:          halt
+# Required-Start:
+# Required-Stop:
+# Default-Start:
+# Default-Stop:      0
+# Short-Description: Execute the halt command.
+# Description:
+### END INIT INFO
+
+NETDOWN=yes
+
+PATH=/sbin:/usr/sbin:/bin:/usr/bin
+[ -f /etc/default/halt ] && . /etc/default/halt
+
+. /lib/lsb/init-functions
+
+do_stop () {
+	if [ "$INIT_HALT" = "" ]
+	then
+		case "$HALT" in
+		  [Pp]*)
+			INIT_HALT=POWEROFF
+			;;
+		  [Hh]*)
+			INIT_HALT=HALT
+			;;
+		  *)
+			INIT_HALT=POWEROFF
+			;;
+		esac
+	fi
+
+	# See if we need to cut the power.
+	if [ "$INIT_HALT" = "POWEROFF" ] && [ -x /etc/init.d/ups-monitor ]
+	then
+		/etc/init.d/ups-monitor poweroff
+	fi
+
+	# Don't shut down drives if we're using RAID.
+	hddown="-h"
+	if grep -qs '^md.*active' /proc/mdstat
+	then
+		hddown=""
+	fi
+
+	# If INIT_HALT=HALT don't poweroff.
+	poweroff="-p"
+	if [ "$INIT_HALT" = "HALT" ]
+	then
+		poweroff=""
+	fi
+
+	# Make it possible to not shut down network interfaces,
+	# needed to use wake-on-lan
+	netdown="-i"
+	if [ "$NETDOWN" = "no" ]; then
+		netdown=""
+	fi
+
+	log_action_msg "Will now halt"
+	halt -d -f $netdown $poweroff $hddown
+}
+
+case "$1" in
+  start)
+	# No-op
+	;;
+  restart|reload|force-reload)
+	echo "Error: argument '$1' not supported" >&2
+	exit 3
+	;;
+  stop)
+	do_stop
+	;;
+  *)
+	echo "Usage: $0 start|stop" >&2
+	exit 3
+	;;
+esac
+
+:
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/hostname.sh sysvinit/initscripts/etc/init.d/hostname.sh
--- sysvinit-2.87dsf/initscripts/etc/init.d/hostname.sh	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/hostname.sh	2011-07-26 02:05:43.386000853 +0900
@@ -0,0 +1,68 @@
+#! /bin/sh
+### BEGIN INIT INFO
+# Provides:          hostname
+# Required-Start:
+# Required-Stop:
+# Should-Start:      glibc
+# Default-Start:     S
+# Default-Stop:
+# Short-Description: Set hostname based on /etc/hostname
+# Description:       Read the machines hostname from /etc/hostname, and
+#                    update the kernel value with this value.  If
+#                    /etc/hostname is empty, the current kernel value
+#                    for hostname is used.  If the kernel value is
+#                    empty, the value 'localhost' is used.
+### END INIT INFO
+
+PATH=/sbin:/bin
+
+. /lib/init/vars.sh
+. /lib/lsb/init-functions
+
+do_start () {
+	[ -f /etc/hostname ] && HOSTNAME="$(cat /etc/hostname)"
+
+	# Keep current name if /etc/hostname is missing.
+	[ -z "$HOSTNAME" ] && HOSTNAME="$(hostname)"
+
+	# And set it to 'localhost' if no setting was found
+	[ -z "$HOSTNAME" ] && HOSTNAME=localhost
+
+	[ "$VERBOSE" != no ] && log_action_begin_msg "Setting hostname to '$HOSTNAME'"
+	hostname "$HOSTNAME"
+	ES=$?
+	[ "$VERBOSE" != no ] && log_action_end_msg $ES
+	exit $ES
+}
+
+do_status () {
+	HOSTNAME=$(hostname)
+	if [ "$HOSTNAME" ] ; then
+		return 0
+	else
+		return 4
+	fi
+}
+
+case "$1" in
+  start|"")
+	do_start
+	;;
+  restart|reload|force-reload)
+	echo "Error: argument '$1' not supported" >&2
+	exit 3
+	;;
+  stop)
+	# No-op
+	;;
+  status)
+	do_status
+	echo $?
+	;;
+  *)
+	echo "Usage: hostname.sh [start|stop]" >&2
+	exit 3
+	;;
+esac
+
+:
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/killprocs sysvinit/initscripts/etc/init.d/killprocs
--- sysvinit-2.87dsf/initscripts/etc/init.d/killprocs	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/killprocs	2011-07-26 02:05:43.386000853 +0900
@@ -0,0 +1,62 @@
+#! /bin/sh
+### BEGIN INIT INFO
+# Provides:          killprocs
+# Required-Start:    $local_fs
+# Required-Stop:
+# Default-Start:     1
+# Default-Stop:
+# Short-Description: executed by init(8) upon entering runlevel 1 (single).
+### END INIT INFO
+
+PATH=/sbin:/usr/sbin:/bin:/usr/bin
+
+. /lib/lsb/init-functions
+
+do_start () {
+	# Kill all processes.
+	log_action_begin_msg "Asking all remaining processes to terminate"
+	killall5 -15 # SIGTERM
+	log_action_end_msg 0
+	alldead=""
+	for seq in 1 2 3 4 5 6 7 8 9 10; do
+		# use SIGCONT/signal 18 to check if there are
+		# processes left.  No need to check the exit code
+		# value, because either killall5 work and it make
+		# sense to wait for processes to die, or it fail and
+		# there is nothing to wait for.
+		
+		if killall5 -18 ; then
+		    :
+		else
+		    alldead=1
+		    break
+		fi
+
+		sleep 1
+	done
+	if [ -z "$alldead" ] ; then
+	    log_action_begin_msg "Killing all remaining processes"
+	    killall5 -9 # SIGKILL
+	    log_action_end_msg 1
+	else
+	    log_action_begin_msg "All processes ended within $seq seconds."
+	    log_action_end_msg 0
+	fi
+}
+
+case "$1" in
+  start)
+	do_start
+	;;
+  restart|reload|force-reload)
+	echo "Error: argument '$1' not supported" >&2
+	exit 3
+	;;
+  stop)
+	# No-op
+	;;
+  *)
+	echo "Usage: $0 start|stop" >&2
+	exit 3
+	;;
+esac
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/mountall-bootclean.sh sysvinit/initscripts/etc/init.d/mountall-bootclean.sh
--- sysvinit-2.87dsf/initscripts/etc/init.d/mountall-bootclean.sh	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/mountall-bootclean.sh	2011-07-26 02:05:43.386000853 +0900
@@ -0,0 +1,34 @@
+#! /bin/sh
+### BEGIN INIT INFO
+# Provides:          mountall-bootclean
+# Required-Start:    mountall
+# Required-Stop:
+# Default-Start:     S
+# Default-Stop:
+# Short-Description: bootclean after mountall.
+# Description:       Clean temporary filesystems after
+#                    all local filesystems have been mounted.
+### END INIT INFO
+
+## We don't need this on SLP platform
+[ -e /etc/init.d/.slp ] && exit 0
+
+case "$1" in
+  start|"")
+	# Clean /tmp, /var/lock, /var/run
+	. /lib/init/bootclean.sh
+	;;
+  restart|reload|force-reload)
+	echo "Error: argument '$1' not supported" >&2
+	exit 3
+	;;
+  stop)
+	# No-op
+	;;
+  *)
+	echo "Usage: mountall-bootclean.sh [start|stop]" >&2
+	exit 3
+	;;
+esac
+
+:
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/mountall.sh sysvinit/initscripts/etc/init.d/mountall.sh
--- sysvinit-2.87dsf/initscripts/etc/init.d/mountall.sh	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/mountall.sh	2011-07-26 02:05:43.387000850 +0900
@@ -0,0 +1,107 @@
+#! /bin/sh
+### BEGIN INIT INFO
+# Provides:          mountall
+# Required-Start:    checkfs
+# Required-Stop: 
+# Default-Start:     S
+# Default-Stop:
+# Short-Description: Mount all filesystems.
+# Description:
+### END INIT INFO
+
+PATH=/sbin:/bin
+. /lib/init/vars.sh
+
+. /lib/lsb/init-functions
+. /lib/init/mount-functions.sh
+
+# for ntfs-3g to get correct file name encoding
+if [ -r /etc/default/locale ]; then
+	. /etc/default/locale
+	export LANG
+fi
+
+do_start() {
+	#
+	# Mount local file systems in /etc/fstab.
+	#
+	mount_all_local() {
+	## Busybox mount does not support -O switch...
+	#    mount -a -t nonfs,nfs4,smbfs,cifs,ncp,ncpfs,coda,ocfs2,gfs,gfs2 \
+	#	-O no_netdev
+	     mount -a -t nonfs,nfs4,smbfs,cifs,ncp,ncpfs,coda,ocfs2,gfs,gfs2
+	}
+	pre_mountall
+	if [ "$VERBOSE" = no ]
+	then
+		log_action_begin_msg "Mounting local filesystems"
+		mount_all_local
+		log_action_end_msg $?
+	else
+		log_daemon_msg "Will now mount local filesystems"
+		mount_all_local
+		log_end_msg $?
+	fi
+	post_mountall
+
+	case "$(uname -s)" in
+	  *FreeBSD)
+		INITCTL=/etc/.initctl
+		;;
+	  *)
+		INITCTL=/dev/initctl
+		;;
+	esac
+
+	#
+	# We might have mounted something over /dev, see if
+	# /dev/initctl is there.
+	#
+	if [ ! -p $INITCTL ]
+	then
+		rm -f $INITCTL
+		mknod -m 600 $INITCTL p
+	fi
+	kill -USR1 1
+
+	#
+	# Execute swapon command again, in case we want to swap to
+	# a file on a now mounted filesystem.
+	#
+	# Ignore 255 status due to swap already being enabled
+	#
+	if [ "$NOSWAP" = yes ]
+	then
+		[ "$VERBOSE" = no ] || log_warning_msg "Not activating swap as requested via bootoption noswap."
+	else
+		if [ "$VERBOSE" = no ]
+		then
+			log_action_begin_msg "Activating swapfile swap"
+			swapon -a -e 2>/dev/null || :  # Stifle "Device or resource busy"
+			log_action_end_msg 0
+		else
+			log_daemon_msg "Will now activate swapfile swap"
+			swapon -a -e -v
+			log_action_end_msg $?
+		fi
+	fi
+}
+
+case "$1" in
+  start|"")
+	do_start
+	;;
+  restart|reload|force-reload)
+	echo "Error: argument '$1' not supported" >&2
+	exit 3
+	;;
+  stop)
+	# No-op
+	;;
+  *)
+	echo "Usage: mountall.sh [start|stop]" >&2
+	exit 3
+	;;
+esac
+
+:
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/mountdevsubfs.sh sysvinit/initscripts/etc/init.d/mountdevsubfs.sh
--- sysvinit-2.87dsf/initscripts/etc/init.d/mountdevsubfs.sh	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/mountdevsubfs.sh	2011-07-26 02:05:43.387000850 +0900
@@ -0,0 +1,97 @@
+#! /bin/sh
+### BEGIN INIT INFO
+# Provides:          mountdevsubfs
+# Required-Start:    mountkernfs
+# Required-Stop:
+# Should-Start:      udev
+# Default-Start:     S
+# Default-Stop:
+# Short-Description: Mount special file systems under /dev.
+# Description:       Mount the virtual filesystems the kernel provides
+#                    that ordinarily live under the /dev filesystem.
+### END INIT INFO
+#
+# This script gets called multiple times during boot
+#
+
+PATH=/sbin:/bin
+TTYGRP=5
+TTYMODE=620
+[ -f /etc/default/devpts ] && . /etc/default/devpts
+
+TMPFS_SIZE=
+[ -f /etc/default/tmpfs ] && . /etc/default/tmpfs
+
+KERNEL="$(uname -s)"
+
+. /lib/lsb/init-functions
+. /lib/init/mount-functions.sh
+
+do_start () {
+	#
+	# Mount a tmpfs on /dev/shm
+	#
+	SHM_OPT=
+	[ "${SHM_SIZE:=$TMPFS_SIZE}" ] && SHM_OPT=",size=$SHM_SIZE"
+	domount tmpfs shmfs /dev/shm tmpfs -onosuid,nodev$SHM_OPT
+
+	#
+	# Mount /dev/pts. Create master ptmx node if needed.
+	#
+	# As of 2.5.68, devpts is not automounted when using devfs. So we
+	# mount devpts if it is compiled in (older devfs didn't require it
+	# to be compiled in at all).
+	#
+	if [ "$KERNEL" = Linux ]
+	then
+		#
+		# Since kernel 2.5.something, devfs doesn't include
+		# a standard /dev/pts directory anymore. So if devfs
+		# is mounted on /dev we need to create that directory
+		# manually.
+		#
+		if [ ! -d /dev/pts ]
+		then
+			if grep -qs '/dev devfs' /proc/mounts
+			then
+				mkdir --mode=755 /dev/pts
+				[ -x /sbin/restorecon ] && /sbin/restorecon /dev/pts
+			fi
+		fi
+		if [ -d /dev/pts ]
+		then
+			if [ ! -c /dev/ptmx ]
+			then
+				mknod --mode=666 /dev/ptmx c 5 2
+				ES=$?
+				if [ "$ES" != 0 ]
+				then
+					log_warning_msg "Failed making node /dev/ptmx with error code ${ES}."
+				fi
+				[ -x /sbin/restorecon ] && /sbin/restorecon /dev/ptmx
+			fi
+			domount devpts "" /dev/pts devpts -onoexec,nosuid,gid=$TTYGRP,mode=$TTYMODE
+		fi
+	fi
+}
+
+case "$1" in
+  "")
+	echo "Warning: mountdevsubfs should be called with the 'start' argument." >&2
+	do_start
+	;;
+  start)
+	do_start
+	;;
+  restart|reload|force-reload)
+	echo "Error: argument '$1' not supported" >&2
+	exit 3
+	;;
+  stop)
+	# No-op
+	;;
+  *)
+	echo "Usage: mountdevsubfs [start|stop]" >&2
+	exit 3
+	;;
+esac
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/mountkernfs.sh sysvinit/initscripts/etc/init.d/mountkernfs.sh
--- sysvinit-2.87dsf/initscripts/etc/init.d/mountkernfs.sh	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/mountkernfs.sh	2011-07-26 02:05:43.387000850 +0900
@@ -0,0 +1,83 @@
+#! /bin/sh
+### BEGIN INIT INFO
+# Provides:          mountkernfs
+# Required-Start:
+# Required-Stop:
+# Should-Start:      glibc
+# Default-Start:     S
+# Default-Stop:
+# Short-Description: Mount kernel virtual file systems.
+# Description:       Mount initial set of virtual filesystems the kernel
+#                    provides and that are required by everything.
+### END INIT INFO
+
+PATH=/sbin:/bin
+. /lib/init/vars.sh
+
+. /lib/lsb/init-functions
+. /lib/init/mount-functions.sh
+
+[ -f /etc/default/tmpfs ] && . /etc/default/tmpfs
+
+do_start () {
+	#
+	# Get some writable area available before the root is checked
+	# and remounted.
+	#
+	RW_OPT=
+	[ "${RW_SIZE:=$TMPFS_SIZE}" ] && RW_OPT=",size=$RW_SIZE"
+	domount tmpfs "" /lib/init/rw tmpfs -omode=0755,nosuid$RW_OPT
+	touch /lib/init/rw/.ramfs
+
+	# Make pidfile omit directory for sendsigs
+	mkdir /lib/init/rw/sendsigs.omit.d/
+
+	#
+	# Mount proc filesystem on /proc
+	#
+	domount proc "" /proc proc -onodev,noexec,nosuid
+
+	#
+	# Mount sysfs on /sys
+	#
+	# Only mount sysfs if it is supported (kernel >= 2.6)
+	if grep -E -qs "sysfs\$" /proc/filesystems
+	then
+		domount sysfs "" /sys sysfs -onodev,noexec,nosuid
+	fi
+
+	# Mount /var/run and /var/lock as tmpfs if enabled
+	if [ yes = "$RAMRUN" ] ; then
+		RUN_OPT=
+		[ "${RUN_SIZE:=$TMPFS_SIZE}" ] && RUN_OPT=",size=$RUN_SIZE"
+		domount tmpfs "" /var/run varrun -omode=0755,nosuid$RUN_OPT
+		touch /var/run/.ramfs
+	fi
+	if [ yes = "$RAMLOCK" ] ; then
+		LOCK_OPT=
+		[ "${LOCK_SIZE:=$TMPFS_SIZE}" ] && LOCK_OPT=",size=$LOCK_SIZE"
+		domount tmpfs "" /var/lock varlock -omode=1777,nodev,noexec,nosuid$LOCK_OPT
+		touch /var/lock/.ramfs
+	fi
+}
+
+case "$1" in
+  "")
+	echo "Warning: mountkernfs should be called with the 'start' argument." >&2
+	do_start
+	;;
+  start)
+	do_start
+	;;
+  restart|reload|force-reload)
+	echo "Error: argument '$1' not supported" >&2
+	exit 3
+	;;
+  stop)
+	# No-op
+	;;
+  *)
+	echo "Usage: mountkernfs [start|stop]" >&2
+	exit 3
+	;;
+esac
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/mountnfs-bootclean.sh sysvinit/initscripts/etc/init.d/mountnfs-bootclean.sh
--- sysvinit-2.87dsf/initscripts/etc/init.d/mountnfs-bootclean.sh	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/mountnfs-bootclean.sh	2011-07-26 02:05:43.387000850 +0900
@@ -0,0 +1,34 @@
+#! /bin/sh
+### BEGIN INIT INFO
+# Provides:          mountnfs-bootclean
+# Required-Start:    $local_fs mountnfs
+# Required-Stop:
+# Default-Start:     S
+# Default-Stop:
+# Short-Description: bootclean after mountnfs.
+# Description:       Clean temporary filesystems after
+#                    network filesystems have been mounted.
+### END INIT INFO
+
+## We don't need this on SLP platform
+[ -e /etc/init.d/.slp ] && exit 0
+
+case "$1" in
+  start|"")
+	# Clean /tmp, /var/lock, /var/run
+	. /lib/init/bootclean.sh
+	;;
+  restart|reload|force-reload)
+	echo "Error: argument '$1' not supported" >&2
+	exit 3
+	;;
+  stop)
+	# No-op
+	;;
+  *)
+	echo "Usage: mountnfs-bootclean.sh [start|stop]" >&2
+	exit 3
+	;;
+esac
+
+:
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/mountnfs.sh sysvinit/initscripts/etc/init.d/mountnfs.sh
--- sysvinit-2.87dsf/initscripts/etc/init.d/mountnfs.sh	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/mountnfs.sh	2011-07-26 02:05:43.387000850 +0900
@@ -0,0 +1,108 @@
+#! /bin/sh
+### BEGIN INIT INFO
+# Provides:          mountnfs
+# Required-Start:    $local_fs
+# Required-Stop:
+# Should-Start:      $network $portmap nfs-common  udev-mtab
+# Default-Start:     S
+# Default-Stop:
+# Short-Description: Wait for network file systems to be mounted
+# Description:       Network file systems are mounted by
+#                    /etc/network/if-up.d/mountnfs in the background
+#                    when interfaces are brought up; this script waits
+#                    for them to be mounted before carrying on.
+### END INIT INFO
+
+. /lib/init/vars.sh
+. /lib/lsb/init-functions
+
+do_wait_async_mount() {
+	[ -f /etc/fstab ] || return
+	#
+	# Read through fstab line by line. If it is NFS, set the flag
+	# for mounting NFS file systems. If any NFS partition is found
+	# then wait around for it.
+	#
+
+	exec 9<&0 </etc/fstab
+
+	waitnfs=
+	while read DEV MTPT FSTYPE OPTS REST
+	do
+		case "$DEV" in
+		  ""|\#*)
+			continue
+			;;
+		esac
+		case "$OPTS" in
+		  noauto|*,noauto|noauto,*|*,noauto,*)
+			continue
+			;;
+		esac
+		case "$FSTYPE" in
+		  nfs|nfs4|smbfs|cifs|coda|ncp|ncpfs|ocfs2|gfs)
+			;;
+		  *)
+			continue
+			;;
+		esac
+		case "$MTPT" in
+		  /usr/local|/usr/local/*)
+			;;
+		  /usr|/usr/*)
+			waitnfs="$waitnfs $MTPT"
+			;;
+		  /var|/var/*)
+			waitnfs="$waitnfs $MTPT"
+			;;
+		esac
+	done
+
+	exec 0<&9 9<&-
+
+	# Wait for each path, the timeout is for all of them as that's
+	# really the maximum time we have to wait anyway
+	TIMEOUT=900
+	for mountpt in $waitnfs; do
+		log_action_begin_msg "Waiting for $mountpt"
+
+		while ! mountpoint -q $mountpt; do
+			sleep 0.1
+
+			TIMEOUT=$(( $TIMEOUT - 1 ))
+			if [ $TIMEOUT -le 0 ]; then
+				log_action_end_msg 1
+				break
+			fi
+		done
+
+		if [ $TIMEOUT -gt 0 ]; then
+			log_action_end_msg 0
+		fi
+	done
+}
+
+case "$1" in
+    start)
+        # Using 'no !=' instead of 'yes =' to make sure async nfs
+        # mounting is the default even without a value in
+        # /etc/default/rcS
+        if [ no != "$ASYNCMOUNTNFS" ] ; then
+                do_wait_async_mount
+        else
+                FROMINITD=yes /etc/network/if-up.d/mountnfs
+        fi
+        ;;
+    restart|reload|force-reload)
+        echo "Error: argument '$1' not supported" >&2
+        exit 3
+        ;;
+    stop)
+        ;;
+    *)
+        echo "Usage: $0 start|stop" >&2
+        exit 3
+        ;;
+esac
+
+: exit 0
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/mountoverflowtmp sysvinit/initscripts/etc/init.d/mountoverflowtmp
--- sysvinit-2.87dsf/initscripts/etc/init.d/mountoverflowtmp	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/mountoverflowtmp	2011-07-26 02:05:43.386000853 +0900
@@ -0,0 +1,58 @@
+#! /bin/sh
+### BEGIN INIT INFO
+# Provides:          mountoverflowtmp
+# Required-Start:    mountall-bootclean
+# Required-Stop:     umountfs
+# Default-Start:     S
+# Default-Stop:
+# Short-Description: mount emergency /tmp.
+# Description:       Mount a tmpfs on /tmp if there would
+#                    otherwise be too little space to log in.
+### END INIT INFO
+
+## We don't need this on SLP platform
+[ -e /etc/init.d/.slp ] && exit 0
+
+. /lib/init/vars.sh
+. /lib/lsb/init-functions
+
+set -e
+
+defs=/etc/default/mountoverflowtmp
+test ! -f "$defs" || . "$defs"
+
+: ${MINTMPKB:=1024}
+if test "$MINTMPKB" = "0"; then exit 0; fi
+
+case "$1" in
+  start)
+	[ "$VERBOSE" != no ] && log_action_begin_msg "Checking minimum space in /tmp"
+	df="`LC_ALL=C df -kP /tmp | grep -v Filesystem`"
+	set -- $df
+	avail="$4"
+	[ "$VERBOSE" != no ] && log_action_end_msg 0
+	if test $avail -lt "$MINTMPKB"; then
+		log_action_begin_msg "Mounting emergency tmpfs on /tmp"
+		mount -t tmpfs -o size=1048576,mode=1777 overflow /tmp
+		log_action_end_msg 0
+	fi
+	;;
+  restart|reload|force-reload)
+	echo "Error: argument '$1' not supported" >&2
+	exit 3
+	;;
+  stop)
+	if LC_ALL=C mount | \
+		grep '^overflow on /tmp type tmpfs' >/dev/null; then
+		log_action_begin_msg "Unmounting any overflow tmpfs from /tmp"
+		umount overflow
+		log_action_end_msg 0
+	fi
+	;;
+  *)
+	echo "Usage: mountoverflowtmp [start|stop]" >&2
+	exit 3
+	;;
+esac
+
+:
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/mtab.sh sysvinit/initscripts/etc/init.d/mtab.sh
--- sysvinit-2.87dsf/initscripts/etc/init.d/mtab.sh	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/mtab.sh	2011-07-26 02:05:43.386000853 +0900
@@ -0,0 +1,183 @@
+#! /bin/sh
+### BEGIN INIT INFO
+# Provides:          mtab
+# Required-Start:    checkroot
+# Required-Stop:
+# Default-Start:     S
+# Default-Stop:
+# Short-Description: Update mtab file.
+# Description:       Update the mount program's mtab file after
+#                    all local filesystems have been mounted.
+### END INIT INFO
+
+#
+# The main purpose of this script is to update the mtab file to reflect
+# the fact that virtual filesystems were mounted early on, before mtab
+# was writable.
+#
+
+## We don't need this on SLP platform
+[ -e /etc/init.d/.slp ] && exit 0
+
+PATH=/sbin:/bin
+. /lib/init/vars.sh
+
+TTYGRP=5
+TTYMODE=620
+[ -f /etc/default/devpts ] && . /etc/default/devpts
+
+TMPFS_SIZE=
+[ -f /etc/default/tmpfs ] && . /etc/default/tmpfs
+
+KERNEL="$(uname -s)"
+
+. /lib/lsb/init-functions
+. /lib/init/mount-functions.sh
+
+# $1 - fstype
+# $2 - mount point
+# $3 - mount name/device
+# $4 - mount options
+domtab ()
+{
+	# Directory present?
+	if [ ! -d $2 ]
+	then
+		return
+	fi
+
+	# Not mounted?
+	if ! mountpoint -q $2 < /dev/null
+	then
+		return
+	fi
+
+	if [ -n "$3" ]
+	then
+		NAME="$3"
+	else
+		NAME="$1"
+	fi
+
+	# Already recorded?
+	if ! grep -E -sq "^([^ ]+) +$2 +" /etc/mtab < /dev/null
+	then
+		mount -f -t $1 $OPTS $4 $NAME $2 < /dev/null
+	fi
+}
+
+do_start () {
+	DO_MTAB=""
+	MTAB_PATH="$(readlink -f /etc/mtab || :)"
+	case "$MTAB_PATH" in
+	  /proc/*)
+		# Assume that /proc/ is not writable
+		;;
+	  /*)
+		# Only update mtab if it is known to be writable
+		# Note that the touch program is in /usr/bin
+		#if ! touch "$MTAB_PATH" >/dev/null 2>&1
+		#then
+		#	return
+		#fi
+		;;
+	  "")
+		[ -L /etc/mtab ] && MTAB_PATH="$(readlink /etc/mtab)"
+		if [ "$MTAB_PATH" ]
+		then
+			log_failure_msg "Cannot initialize ${MTAB_PATH}."
+		else
+			log_failure_msg "Cannot initialize /etc/mtab."
+		fi
+		;;
+	  *)
+		log_failure_msg "Illegal mtab location '${MTAB_PATH}'."
+		;;
+	esac
+
+	#
+	# Initialize mtab file if necessary
+	#
+	if [ ! -f /etc/mtab ]
+	then
+		:> /etc/mtab
+		chmod 644 /etc/mtab
+	fi
+	if selinux_enabled && [ -x /sbin/restorecon ] && [ -r /etc/mtab ]
+	then
+		restorecon /etc/mtab
+	fi
+
+	# S02mountkernfs.sh
+	RW_OPT=
+	[ "${RW_SIZE:=$TMPFS_SIZE}" ] && RW_OPT=",size=$RW_SIZE"
+	domtab tmpfs /lib/init/rw tmpfs -omode=0755,nosuid$RW_OPT
+
+	domtab proc /proc "proc" -onodev,noexec,nosuid
+	if grep -E -qs "sysfs\$" /proc/filesystems
+	then
+		domtab sysfs /sys sysfs -onodev,noexec,nosuid
+	fi
+	if [ yes = "$RAMRUN" ] ; then
+		RUN_OPT=
+		[ "${RUN_SIZE:=$TMPFS_SIZE}" ] && RUN_OPT=",size=$RUN_SIZE"
+		domtab tmpfs /var/run "varrun" -omode=0755,nosuid$RUN_OPT
+	fi
+	if [ yes = "$RAMLOCK" ] ; then
+		LOCK_OPT=
+		[ "${LOCK_SIZE:=$TMPFS_SIZE}" ] && LOCK_OPT=",size=$LOCK_SIZE"
+		domtab tmpfs /var/lock "varlock" -omode=1777,nodev,noexec,nosuid$LOCK_OPT
+	fi
+	if [ -d /proc/bus/usb ]
+	then
+		domtab usbfs /proc/bus/usb "procbususb"
+	fi
+
+	# S03udev
+	domtab tmpfs /dev "udev" -omode=0755
+
+	# S04mountdevsubfs
+	SHM_OPT=
+	[ "${SHM_SIZE:=$TMPFS_SIZE}" ] && SHM_OPT=",size=$SHM_SIZE"
+	domtab tmpfs /dev/shm tmpfs -onosuid,nodev$SHM_OPT
+	domtab devpts /dev/pts "devpts" -onoexec,nosuid,gid=$TTYGRP,mode=$TTYMODE
+
+	# Add everything else in /proc/mounts into /etc/mtab, with
+	# special exceptions.
+	exec 9<&0 0</proc/mounts
+	while read FDEV FDIR FTYPE FOPTS REST
+	do
+		case "$FDIR" in
+			/lib/modules/*/volatile)
+				FDEV="lrm"
+				;;
+			/dev/.static/dev)
+				# Not really useful to show in 'df',
+				# and it isn't accessible for non-root
+				# users.
+				continue
+				;;
+		esac
+		domtab "$FTYPE" "$FDIR" "$FDEV" "-o$FOPTS"
+	done
+	exec 0<&9 9<&-
+}
+
+case "$1" in
+  start|"")
+	do_start
+	;;
+  restart|reload|force-reload)
+	echo "Error: argument '$1' not supported" >&2
+	exit 3
+	;;
+  stop)
+	# No-op
+	;;
+  *)
+	echo "Usage: mountall-mtab.sh [start|stop]" >&2
+	exit 3
+	;;
+esac
+
+:
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/rc.local sysvinit/initscripts/etc/init.d/rc.local
--- sysvinit-2.87dsf/initscripts/etc/init.d/rc.local	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/rc.local	2011-07-26 02:05:43.386000853 +0900
@@ -0,0 +1,41 @@
+#! /bin/sh
+### BEGIN INIT INFO
+# Provides:          rc.local
+# Required-Start:    $remote_fs $syslog $all
+# Required-Stop:
+# Default-Start:     2 3 4 5
+# Default-Stop:
+# Short-Description: Run /etc/rc.local if it exist
+### END INIT INFO
+
+
+PATH=/sbin:/usr/sbin:/bin:/usr/bin
+
+. /lib/init/vars.sh
+. /lib/lsb/init-functions
+
+do_start() {
+	if [ -x /etc/rc.local ]; then
+	        [ "$VERBOSE" != no ] && log_begin_msg "Running local boot scripts (/etc/rc.local)"
+		/etc/rc.local
+		ES=$?
+		[ "$VERBOSE" != no ] && log_end_msg $ES
+		return $ES
+	fi
+}
+
+case "$1" in
+    start)
+	do_start
+        ;;
+    restart|reload|force-reload)
+        echo "Error: argument '$1' not supported" >&2
+        exit 3
+        ;;
+    stop)
+        ;;
+    *)
+        echo "Usage: $0 start|stop" >&2
+        exit 3
+        ;;
+esac
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/reboot sysvinit/initscripts/etc/init.d/reboot
--- sysvinit-2.87dsf/initscripts/etc/init.d/reboot	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/reboot	2011-07-26 02:05:43.387000850 +0900
@@ -0,0 +1,38 @@
+#! /bin/sh
+### BEGIN INIT INFO
+# Provides:          reboot
+# Required-Start:
+# Required-Stop:
+# Default-Start:
+# Default-Stop:      6
+# Short-Description: Execute the reboot command.
+# Description:
+### END INIT INFO
+
+PATH=/sbin:/usr/sbin:/bin:/usr/bin
+
+. /lib/lsb/init-functions
+
+do_stop () {
+	# Message should end with a newline since kFreeBSD may
+	# print more stuff (see #323749)
+	log_action_msg "Will now restart"
+	reboot -d -f -i
+}
+
+case "$1" in
+  start)
+	# No-op
+	;;
+  restart|reload|force-reload)
+	echo "Error: argument '$1' not supported" >&2
+	exit 3
+	;;
+  stop)
+	do_stop
+	;;
+  *)
+	echo "Usage: $0 start|stop" >&2
+	exit 3
+	;;
+esac
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/rmnologin sysvinit/initscripts/etc/init.d/rmnologin
--- sysvinit-2.87dsf/initscripts/etc/init.d/rmnologin	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/rmnologin	2011-07-26 02:05:43.386000853 +0900
@@ -0,0 +1,59 @@
+#! /bin/sh
+### BEGIN INIT INFO
+# Provides:          rmnologin
+# Required-Start:    $remote_fs $all
+# Required-Stop: 
+# Default-Start:     2 3 4 5
+# Default-Stop:
+# Short-Description: Remove /etc/nologin at boot
+# Description:       This script removes the /etc/nologin file as the
+#                    last step in the boot process, if DELAYLOGIN=yes.
+#                    If DELAYLOGIN=no, /etc/nologin was not created by
+#                    bootmisc earlier in the boot process.
+### END INIT INFO
+
+PATH=/sbin:/bin
+[ "$DELAYLOGIN" ] || DELAYLOGIN=yes
+. /lib/init/vars.sh
+
+do_start () {
+	#
+	# If login delaying is enabled then remove the flag file
+	#
+	case "$DELAYLOGIN" in
+	  Y*|y*)
+		rm -f /var/lib/initscripts/nologin
+		;;
+	esac
+}
+
+do_status () {
+	if [ ! -f /var/lib/initscripts/nologin ] ; then
+		return 0
+	else
+		return 4
+	fi
+}
+
+case "$1" in
+  start)
+	do_start
+	;;
+  restart|reload|force-reload)
+	echo "Error: argument '$1' not supported" >&2
+	exit 3
+	;;
+  stop)
+	# No-op
+	;;
+  status)
+	do_status
+	echo $?
+	;;
+  *)
+	echo "Usage: $0 start|stop" >&2
+	exit 3
+	;;
+esac
+
+:
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/sendsigs sysvinit/initscripts/etc/init.d/sendsigs
--- sysvinit-2.87dsf/initscripts/etc/init.d/sendsigs	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/sendsigs	2011-07-26 02:05:43.387000850 +0900
@@ -0,0 +1,96 @@
+#! /bin/sh
+### BEGIN INIT INFO
+# Provides:          sendsigs
+# Required-Start:    
+# Required-Stop:     umountnfs
+# Default-Start:
+# Default-Stop:      0 6
+# Short-Description: Kill all remaining processes.
+# Description: 
+### END INIT INFO
+
+PATH=/sbin:/usr/sbin:/bin:/usr/bin
+
+. /lib/lsb/init-functions
+
+do_stop () {
+	OMITPIDS=
+
+	# The /var/run/sendsigs.omit file is used to be compatible
+	# with Ubuntu.
+	for omitfile in /var/run/sendsigs.omit /lib/init/rw/sendsigs.omit; do
+		if [ -e $omitfile ]; then
+			for pid in $(cat $omitfile); do
+				OMITPIDS="${OMITPIDS:+$OMITPIDS }-o $pid"
+			done
+		fi
+	done
+
+	# Load sendsigs.omit.d/packagename files too, to make it
+	# possible for scripts that need to modify the list of pids at
+	# run time without race conditions.
+	if [ -d /lib/init/rw/sendsigs.omit.d/ ]; then
+		for pidfile in /lib/init/rw/sendsigs.omit.d/*; do
+			[ -f "$pidfile" ] || continue
+			for pid in $(cat $pidfile); do
+				OMITPIDS="${OMITPIDS:+$OMITPIDS }-o $pid"
+			done
+		done
+	fi
+
+	# Flush the kernel I/O buffer before we start to kill
+	# processes, to make sure the IO of already stopped services to
+	# not slow down the remaining processes to a point where they
+	# are accidentily killed with SIGKILL because they did not
+	# manage to shut down in time.
+	sync
+
+	# Kill all processes.
+	log_action_begin_msg "Asking all remaining processes to terminate"
+	killall5 -15 $OMITPIDS # SIGTERM
+	log_action_end_msg 0
+	alldead=""
+	for seq in 1 2 3 4 5 6 7 8 9 10; do
+		# use SIGCONT/signal 18 to check if there are
+		# processes left.  No need to check the exit code
+		# value, because either killall5 work and it make
+		# sense to wait for processes to die, or it fail and
+		# there is nothing to wait for.
+		
+		if killall5 -18 $OMITPIDS ; then
+		    :
+		else
+		    alldead=1
+		    break
+		fi
+
+		sleep 1
+	done
+	if [ -z "$alldead" ] ; then
+	    log_action_begin_msg "Killing all remaining processes"
+	    killall5 -9 $OMITPIDS # SIGKILL
+	    log_action_end_msg 1
+	else
+	    log_action_begin_msg "All processes ended within $seq seconds."
+	    log_action_end_msg 0
+	fi
+}
+
+case "$1" in
+  start)
+	# No-op
+	;;
+  restart|reload|force-reload)
+	echo "Error: argument '$1' not supported" >&2
+	exit 3
+	;;
+  stop)
+	do_stop
+	;;
+  *)
+	echo "Usage: $0 start|stop" >&2
+	exit 3
+	;;
+esac
+
+:
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/single sysvinit/initscripts/etc/init.d/single
--- sysvinit-2.87dsf/initscripts/etc/init.d/single	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/single	2011-07-26 02:05:43.386000853 +0900
@@ -0,0 +1,35 @@
+#! /bin/sh
+### BEGIN INIT INFO
+# Provides:          single
+# Required-Start:    $local_fs $all killprocs
+# Required-Stop:
+# Default-Start:     1
+# Default-Stop:
+# Short-Description: executed by init(8) upon entering runlevel 1 (single).
+### END INIT INFO
+
+PATH=/sbin:/bin
+
+. /lib/lsb/init-functions
+
+do_start () {
+	log_action_msg "Will now switch to single-user mode"
+	exec init -t1 S
+}
+
+case "$1" in
+  start)
+	do_start
+	;;
+  restart|reload|force-reload)
+	echo "Error: argument '$1' not supported" >&2
+	exit 3
+	;;
+  stop)
+	# No-op
+	;;
+  *)
+	echo "Usage: $0 start|stop" >&2
+	exit 3
+	;;
+esac
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/skeleton sysvinit/initscripts/etc/init.d/skeleton
--- sysvinit-2.87dsf/initscripts/etc/init.d/skeleton	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/skeleton	2011-07-26 02:05:43.386000853 +0900
@@ -0,0 +1,158 @@
+#! /bin/sh
+### BEGIN INIT INFO
+# Provides:          skeleton
+# Required-Start:    $remote_fs $syslog
+# Required-Stop:     $remote_fs $syslog
+# Default-Start:     2 3 4 5
+# Default-Stop:      0 1 6
+# Short-Description: Example initscript
+# Description:       This file should be used to construct scripts to be
+#                    placed in /etc/init.d.
+### END INIT INFO
+
+# Author: Foo Bar <foobar@baz.org>
+#
+# Please remove the "Author" lines above and replace them
+# with your own name if you copy and modify this script.
+
+# Do NOT "set -e"
+
+# PATH should only include /usr/* if it runs after the mountnfs.sh script
+PATH=/sbin:/usr/sbin:/bin:/usr/bin
+DESC="Description of the service"
+NAME=daemonexecutablename
+DAEMON=/usr/sbin/$NAME
+DAEMON_ARGS="--options args"
+PIDFILE=/var/run/$NAME.pid
+SCRIPTNAME=/etc/init.d/$NAME
+
+# Exit if the package is not installed
+[ -x "$DAEMON" ] || exit 0
+
+# Read configuration variable file if it is present
+[ -r /etc/default/$NAME ] && . /etc/default/$NAME
+
+# Load the VERBOSE setting and other rcS variables
+. /lib/init/vars.sh
+
+# Define LSB log_* functions.
+# Depend on lsb-base (>= 3.0-6) to ensure that this file is present.
+. /lib/lsb/init-functions
+
+#
+# Function that starts the daemon/service
+#
+do_start()
+{
+	# Return
+	#   0 if daemon has been started
+	#   1 if daemon was already running
+	#   2 if daemon could not be started
+	start-stop-daemon --start --quiet --pidfile $PIDFILE --exec $DAEMON --test > /dev/null \
+		|| return 1
+	start-stop-daemon --start --quiet --pidfile $PIDFILE --exec $DAEMON -- \
+		$DAEMON_ARGS \
+		|| return 2
+	# Add code here, if necessary, that waits for the process to be ready
+	# to handle requests from services started subsequently which depend
+	# on this one.  As a last resort, sleep for some time.
+}
+
+#
+# Function that stops the daemon/service
+#
+do_stop()
+{
+	# Return
+	#   0 if daemon has been stopped
+	#   1 if daemon was already stopped
+	#   2 if daemon could not be stopped
+	#   other if a failure occurred
+	start-stop-daemon --stop --quiet --retry=TERM/30/KILL/5 --pidfile $PIDFILE --name $NAME
+	RETVAL="$?"
+	[ "$RETVAL" = 2 ] && return 2
+	# Wait for children to finish too if this is a daemon that forks
+	# and if the daemon is only ever run from this initscript.
+	# If the above conditions are not satisfied then add some other code
+	# that waits for the process to drop all resources that could be
+	# needed by services started subsequently.  A last resort is to
+	# sleep for some time.
+	start-stop-daemon --stop --quiet --oknodo --retry=0/30/KILL/5 --exec $DAEMON
+	[ "$?" = 2 ] && return 2
+	# Many daemons don't delete their pidfiles when they exit.
+	rm -f $PIDFILE
+	return "$RETVAL"
+}
+
+#
+# Function that sends a SIGHUP to the daemon/service
+#
+do_reload() {
+	#
+	# If the daemon can reload its configuration without
+	# restarting (for example, when it is sent a SIGHUP),
+	# then implement that here.
+	#
+	start-stop-daemon --stop --signal 1 --quiet --pidfile $PIDFILE --name $NAME
+	return 0
+}
+
+case "$1" in
+  start)
+	[ "$VERBOSE" != no ] && log_daemon_msg "Starting $DESC" "$NAME"
+	do_start
+	case "$?" in
+		0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
+		2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
+	esac
+	;;
+  stop)
+	[ "$VERBOSE" != no ] && log_daemon_msg "Stopping $DESC" "$NAME"
+	do_stop
+	case "$?" in
+		0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
+		2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
+	esac
+	;;
+  status)
+       status_of_proc "$DAEMON" "$NAME" && exit 0 || exit $?
+       ;;
+  #reload|force-reload)
+	#
+	# If do_reload() is not implemented then leave this commented out
+	# and leave 'force-reload' as an alias for 'restart'.
+	#
+	#log_daemon_msg "Reloading $DESC" "$NAME"
+	#do_reload
+	#log_end_msg $?
+	#;;
+  restart|force-reload)
+	#
+	# If the "reload" option is implemented then remove the
+	# 'force-reload' alias
+	#
+	log_daemon_msg "Restarting $DESC" "$NAME"
+	do_stop
+	case "$?" in
+	  0|1)
+		do_start
+		case "$?" in
+			0) log_end_msg 0 ;;
+			1) log_end_msg 1 ;; # Old process is still running
+			*) log_end_msg 1 ;; # Failed to start
+		esac
+		;;
+	  *)
+	  	# Failed to stop
+		log_end_msg 1
+		;;
+	esac
+	;;
+  *)
+	#echo "Usage: $SCRIPTNAME {start|stop|restart|reload|force-reload}" >&2
+	echo "Usage: $SCRIPTNAME {start|stop|status|restart|force-reload}" >&2
+	exit 3
+	;;
+esac
+
+:
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/.slp sysvinit/initscripts/etc/init.d/.slp
--- sysvinit-2.87dsf/initscripts/etc/init.d/.slp	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/.slp	2011-07-26 02:05:43.386000853 +0900
@@ -0,0 +1 @@
+Samsung Linux Platform
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/stop-bootlogd sysvinit/initscripts/etc/init.d/stop-bootlogd
--- sysvinit-2.87dsf/initscripts/etc/init.d/stop-bootlogd	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/stop-bootlogd	2011-07-26 02:05:43.387000850 +0900
@@ -0,0 +1,30 @@
+#! /bin/sh
+### BEGIN INIT INFO
+# Provides:          stop-bootlogd
+# Required-Start:    $local_fs $all
+# Required-Stop:
+# Default-Start:     2 3 4 5
+# Default-Stop:
+# Short-Description: Stop bootlogd
+# Description:       See the init.d/bootlogd script
+### END INIT INFO
+
+NAME=stop-bootlogd
+DAEMON=/sbin/bootlogd
+
+[ -x "$DAEMON" ] || exit 0
+
+case "$1" in
+  start)
+	/etc/init.d/bootlogd stop
+	;;
+  stop|restart|force-reload)
+	# No-op
+	;;
+  *)
+	echo "Usage: $NAME {start|stop|restart|force-reload}" >&2
+	exit 3
+	;;
+esac
+
+:
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/stop-bootlogd-single sysvinit/initscripts/etc/init.d/stop-bootlogd-single
--- sysvinit-2.87dsf/initscripts/etc/init.d/stop-bootlogd-single	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/stop-bootlogd-single	2011-07-26 02:05:43.386000853 +0900
@@ -0,0 +1,48 @@
+#! /bin/sh
+### BEGIN INIT INFO
+# Provides:          stop-bootlogd-single
+# Required-Start:    $local_fs $all
+# Required-Stop:
+# Default-Start:     S
+# Default-Stop:
+# Short-Description: Stop bootlogd in single user mode
+# Description:       See the init.d/bootlogd script
+### END INIT INFO
+#
+# This has to run in the boot sequence (rcS.d), and not in the "single
+# user" sequence (rc1.d), because rc1.d/ is not used when booting into
+# single user.  "grep :[S1]: /etc/inittab" show that single user is just
+# a call to /sbin/sulogin, while runlevel 1 is a call to
+# "/etc/init.d/rc 1" which in the end switches to runlevel S to run
+# /sbin/sulogin.
+
+PATH=/sbin:/usr/sbin:/bin:/usr/bin
+NAME=stop-bootlogd-single
+DAEMON=/sbin/bootlogd
+
+[ -x "$DAEMON" ] || exit 0
+
+case "$1" in
+  start)
+	single=false
+	for word in $(cat /proc/cmdline); do
+		case "$word" in
+		S|single|1)
+			single=true
+		;;
+		esac
+	done
+	if [ true = "$single" ] ; then
+		/etc/init.d/bootlogd stop
+	fi
+	;;
+  stop|restart|force-reload)
+	# No-op
+	;;
+  *)
+	echo "Usage: $NAME {start|stop|restart|force-reload}" >&2
+	exit 3
+	;;
+esac
+
+:
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/umountfs sysvinit/initscripts/etc/init.d/umountfs
--- sysvinit-2.87dsf/initscripts/etc/init.d/umountfs	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/umountfs	2011-07-26 02:05:43.387000850 +0900
@@ -0,0 +1,124 @@
+#! /bin/sh
+### BEGIN INIT INFO
+# Provides:          umountfs
+# Required-Start:
+# Required-Stop:     umountroot
+# Default-Start:
+# Default-Stop:      0 6
+# Short-Description: Turn off swap and unmount all local file systems.
+# Description:
+### END INIT INFO
+
+PATH=/sbin:/usr/sbin:/bin:/usr/bin
+. /lib/init/vars.sh
+
+. /lib/lsb/init-functions
+
+umask 022
+
+do_stop () {
+	exec 9<&0 </proc/mounts
+
+	REG_MTPTS=""
+	TMPFS_MTPTS=""
+	while read -r DEV MTPT FSTYPE REST
+	do
+		case "$MTPT" in
+		  /|/proc|/dev|/.dev|/dev/pts|/dev/shm|/dev/.static/dev|/proc/*|/sys|/lib/init/rw)
+			continue
+			;;
+		  /var/run)
+			if [ yes = "$RAMRUN" ] ; then
+				continue
+			fi
+			;;
+		  /var/lock)
+			if [ yes = "$RAMLOCK" ] ; then
+				continue
+			fi
+			;;
+		esac
+		case "$FSTYPE" in 
+		  proc|procfs|linprocfs|devfs|sysfs|usbfs|usbdevfs|devpts)
+			continue
+			;;
+		  tmpfs)
+			TMPFS_MTPTS="$MTPT $TMPFS_MTPTS"
+			;;
+		  *)
+			REG_MTPTS="$MTPT $REG_MTPTS"
+			;;
+		esac
+	done
+
+	exec 0<&9 9<&-
+	
+	#
+	# Make sure tmpfs file systems are umounted before turning off
+	# swap, to avoid running out of memory if the tmpfs filesystems
+	# use a lot of space.
+	#
+	if [ "$TMPFS_MTPTS" ]
+	then
+		if [ "$VERBOSE" = no ]
+		then
+			log_action_begin_msg "Unmounting temporary filesystems"
+			fstab-decode umount $TMPFS_MTPTS
+			log_action_end_msg $?
+		else
+			log_daemon_msg "Will now unmount temporary filesystems"
+			fstab-decode umount -v $TMPFS_MTPTS
+			log_end_msg $?
+		fi
+	fi
+
+	#
+	# Deactivate swap
+	#
+	if [ "$VERBOSE" = no ]
+	then
+		log_action_begin_msg "Deactivating swap"
+		swapoff -a >/dev/null
+		log_action_end_msg $?
+	else
+		log_daemon_msg "Will now deactivate swap"
+		swapoff -a -v
+		log_end_msg $?
+	fi
+
+	#
+	# Unmount local filesystems
+	#
+	if [ "$REG_MTPTS" ]
+	then
+		if [ "$VERBOSE" = no ]
+		then
+			log_action_begin_msg "Unmounting local filesystems"
+			fstab-decode umount -f -r -d $REG_MTPTS
+			log_action_end_msg $?
+		else
+			log_daemon_msg "Will now unmount local filesystems"
+			fstab-decode umount -f -v -r -d $REG_MTPTS
+			log_end_msg $?
+		fi
+	fi
+}
+
+case "$1" in
+  start)
+	# No-op
+	;;
+  restart|reload|force-reload)
+	echo "Error: argument '$1' not supported" >&2
+	exit 3
+	;;
+  stop)
+	do_stop
+	;;
+  *)
+	echo "Usage: $0 start|stop" >&2
+	exit 3
+	;;
+esac
+
+:
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/umountnfs.sh sysvinit/initscripts/etc/init.d/umountnfs.sh
--- sysvinit-2.87dsf/initscripts/etc/init.d/umountnfs.sh	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/umountnfs.sh	2011-07-26 02:05:43.387000850 +0900
@@ -0,0 +1,108 @@
+#! /bin/sh
+### BEGIN INIT INFO
+# Provides:          umountnfs
+# Required-Start:
+# Required-Stop:     umountfs
+# Should-Stop:       $network $portmap nfs-common
+# Default-Start:
+# Default-Stop:      0 6
+# Short-Description: Unmount all network filesystems except the root fs.
+# Description:       Also unmounts all virtual filesystems (proc, devfs,
+#                    devpts, usbfs, sysfs) that are not mounted at the
+#                    top level.
+### END INIT INFO
+
+PATH=/sbin:/usr/sbin:/bin:/usr/bin
+KERNEL="$(uname -s)"
+RELEASE="$(uname -r)"
+. /lib/init/vars.sh
+
+. /lib/lsb/init-functions
+
+case "${KERNEL}:${RELEASE}" in
+  Linux:[01].*|Linux:2.[01].*)
+	FLAGS=""
+	;;
+  Linux:2.[23].*|Linux:2.4.?|Linux:2.4.?-*|Linux:2.4.10|Linux:2.4.10-*)
+	FLAGS="-f"
+	;;
+  *)
+	FLAGS="-f -l"
+	;;
+esac
+
+do_stop () {
+	# Write a reboot record to /var/log/wtmp before unmounting
+	halt -w
+
+	# Remove bootclean flag files (precaution against symlink attacks)
+	rm -f /tmp/.clean /var/lock/.clean /var/run/.clean
+
+	#
+	# Make list of points to unmount in reverse order of their creation
+	#
+
+	exec 9<&0 </etc/mtab
+
+	DIRS=""
+	while read -r DEV MTPT FSTYPE OPTS REST
+	do
+		case "$MTPT" in
+		  /|/proc|/dev|/dev/pts|/dev/shm|/proc/*|/sys|/lib/init/rw)
+			continue
+			;;
+		  /var/run)
+			if [ yes = "$RAMRUN" ] ; then
+				continue
+			fi
+			;;
+		  /var/lock)
+			if [ yes = "$RAMLOCK" ] ; then
+				continue
+			fi
+			;;
+		esac
+		case "$FSTYPE" in
+		  nfs|nfs4|smbfs|ncp|ncpfs|cifs|coda|ocfs2|gfs)
+			DIRS="$MTPT $DIRS"
+			;;
+		  proc|procfs|linprocfs|devfs|devpts|usbfs|usbdevfs|sysfs)
+			DIRS="$MTPT $DIRS"
+			;;
+		esac
+		case "$OPTS" in
+		  _netdev|*,_netdev|_netdev,*|*,_netdev,*)
+			DIRS="$MTPT $DIRS"
+			;;
+		esac
+	done
+
+	exec 0<&9 9<&-
+
+	if [ "$DIRS" ]
+	then
+		[ "$VERBOSE" = no ] || log_action_begin_msg "Unmounting remote and non-toplevel virtual filesystems"
+		fstab-decode umount $FLAGS $DIRS
+		ES=$?
+		[ "$VERBOSE" = no ] || log_action_end_msg $ES
+	fi
+}
+
+case "$1" in
+  start)
+	# No-op
+	;;
+  restart|reload|force-reload)
+	echo "Error: argument '$1' not supported" >&2
+	exit 3
+	;;
+  stop|"")
+	do_stop
+	;;
+  *)
+	echo "Usage: umountnfs.sh [start|stop]" >&2
+	exit 3
+	;;
+esac
+
+:
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/umountroot sysvinit/initscripts/etc/init.d/umountroot
--- sysvinit-2.87dsf/initscripts/etc/init.d/umountroot	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/umountroot	2011-07-26 02:05:43.386000853 +0900
@@ -0,0 +1,57 @@
+#! /bin/sh
+### BEGIN INIT INFO
+# Provides:          umountroot
+# Required-Start:
+# Required-Stop:
+# Should-Stop:       halt reboot kexec
+# Default-Start:
+# Default-Stop:      0 6
+# Short-Description: Mount the root filesystem read-only.
+### END INIT INFO
+
+PATH=/sbin:/bin
+. /lib/init/vars.sh
+
+. /lib/lsb/init-functions
+
+do_stop () {
+	[ "$VERBOSE" = no ] || log_action_begin_msg "Mounting root filesystem read-only"
+	# These directories must exist on the root filesystem as they are
+	# targets for system mountpoints.  We've just unmounted all other
+	# filesystems, so either they are mounted now (in which case the
+	# mount point exists) or we can make the mountpoint.
+	for dir in /proc /sys /var/run /var/lock; do
+	    mkdir -p $dir || true
+	done
+
+	MOUNT_FORCE_OPT=
+	[ "$(uname -s)" = "GNU/kFreeBSD" ] && MOUNT_FORCE_OPT=-f
+	# This:
+	#     mount -n -o remount,ro /
+	# will act on a bind mount of / if there is one.
+	# See #339023 and the comment in checkroot.sh
+	mount    $MOUNT_FORCE_OPT -n -o remount,ro -t dummytype dummydev / 2>/dev/null \
+	|| mount $MOUNT_FORCE_OPT -n -o remount,ro              dummydev / 2>/dev/null \
+	|| mount $MOUNT_FORCE_OPT -n -o remount,ro                       /
+	ES=$?
+	[ "$VERBOSE" = no ] || log_action_end_msg $ES
+}
+
+case "$1" in
+  start)
+	# No-op
+	;;
+  restart|reload|force-reload)
+	echo "Error: argument '$1' not supported" >&2
+	exit 3
+	;;
+  stop)
+	do_stop
+	;;
+  *)
+	echo "Usage: $0 start|stop" >&2
+	exit 3
+	;;
+esac
+
+:
diff -ruN sysvinit-2.87dsf/initscripts/etc/init.d/urandom sysvinit/initscripts/etc/init.d/urandom
--- sysvinit-2.87dsf/initscripts/etc/init.d/urandom	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/init.d/urandom	2011-07-26 02:05:43.387000850 +0900
@@ -0,0 +1,80 @@
+#! /bin/sh
+### BEGIN INIT INFO
+# Provides:          urandom
+# Required-Start:    $remote_fs
+# Required-Stop:     $remote_fs
+# Default-Start:     S
+# Default-Stop:      0 6
+# Short-Description: Save and restore random seed between restarts.
+# Description:       This script saves the random seed between restarts.
+#                    It is called from the boot, halt and reboot scripts.
+### END INIT INFO
+
+[ -c /dev/urandom ] || exit 0
+
+PATH=/sbin:/usr/sbin:/bin:/usr/bin
+SAVEDFILE=/var/lib/urandom/random-seed
+POOLSIZE=512
+[ -f /proc/sys/kernel/random/poolsize ] && POOLSIZE="$(cat /proc/sys/kernel/random/poolsize)"
+. /lib/init/vars.sh
+
+. /lib/lsb/init-functions
+
+do_status () {
+	if [ -f $SAVEDFILE ] ; then
+		return 0
+	else
+		return 4
+	fi
+}
+
+case "$1" in
+  start|"")
+	[ "$VERBOSE" = no ] || log_action_begin_msg "Initializing random number generator"
+	# Load and then save $POOLSIZE bytes,
+	# which is the size of the entropy pool
+	if [ -f "$SAVEDFILE" ]
+	then
+		# Handle locally increased pool size
+		## Work around Busybox find not supporting -printf option
+		#SAVEDSIZE="$(find "$SAVEDFILE" -printf "%s")"
+		SAVEDSIZE="$(stat -c "%s" "$SAVEDFILE")"
+		if [ "$SAVEDSIZE" -gt "$POOLSIZE" ]
+		then
+			[ -w /proc/sys/kernel/random/poolsize ] && echo $POOLSIZE > /proc/sys/kernel/random/poolsize
+			POOLSIZE=$SAVEDSIZE
+		fi
+		cat "$SAVEDFILE" >/dev/urandom
+	fi
+	rm -f $SAVEDFILE
+	# Hm, why is the saved pool re-created at boot? [pere 2009-09-03]
+	umask 077
+	dd if=/dev/urandom of=$SAVEDFILE bs=$POOLSIZE count=1 >/dev/null 2>&1
+	ES=$?
+	umask 022
+	[ "$VERBOSE" = no ] || log_action_end_msg $ES
+	;;
+  stop)
+	# Carry a random seed from shut-down to start-up;
+	# see documentation in linux/drivers/char/random.c
+	[ "$VERBOSE" = no ] || log_action_begin_msg "Saving random seed"
+	umask 077
+	dd if=/dev/urandom of=$SAVEDFILE bs=$POOLSIZE count=1 >/dev/null 2>&1
+	ES=$?
+	[ "$VERBOSE" = no ] || log_action_end_msg $ES
+	;;
+  status)
+	do_status
+	exit $?
+	;;
+  restart|reload|force-reload)
+	echo "Error: argument '$1' not supported" >&2
+	exit 3
+	;;
+  *)
+	echo "Usage: urandom start|stop" >&2
+	exit 3
+	;;
+esac
+
+:
diff -ruN sysvinit-2.87dsf/initscripts/etc/network/if-up.d/mountnfs sysvinit/initscripts/etc/network/if-up.d/mountnfs
--- sysvinit-2.87dsf/initscripts/etc/network/if-up.d/mountnfs	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/etc/network/if-up.d/mountnfs	2011-07-26 02:05:43.386000853 +0900
@@ -0,0 +1,173 @@
+#! /bin/sh
+# Description:       Now that TCP/IP is configured, mount the NFS file
+#                    systems in /etc/fstab if needed. If possible,
+#                    start the portmapper before mounting (this is needed for
+#                    Linux 2.1.x and up).
+#
+#                    Also mounts SMB filesystems now, so the name of
+#                    this script is getting increasingly inaccurate.
+
+PATH=/sbin:/bin
+. /lib/init/vars.sh
+
+. /lib/lsb/init-functions
+. /lib/init/mount-functions.sh
+
+set_env() {
+	[ -f /etc/fstab ] || return
+	#
+	# Read through fstab line by line. If it is NFS, set the flag
+	# for mounting NFS file systems. If any NFS partition is found and it
+	# not mounted with the nolock option, we start the portmapper.
+	# 
+	# If any sec={krb5,krb5i,krb5p} option is given, or any of the file
+	# systems are nfs4, we'll need to start rpc.gssd and/or rpc.idmapd too;
+	# we'll leave that to nfs-common.
+	#
+
+	exec 9<&0 </etc/fstab
+
+	start_nfs=no
+	NETFS=""
+	NETDEV=""
+	while read DEV MTPT FSTYPE OPTS REST
+	do
+		case "$DEV" in
+		  ""|\#*)
+			continue
+			;;
+		esac
+		case "$OPTS" in
+		  noauto|*,noauto|noauto,*|*,noauto,*)
+			continue
+			;;
+		  _netdev|*,_netdev|_netdev,*|*,_netdev,*)
+			NETDEV=yes
+			;;
+		esac
+		case "$FSTYPE" in
+		  nfs)
+		  	# NFS filsystems normally require statd and portmap. However,
+			# if nolock is set, portmap and statd are not required for this
+			# file system.
+			case "$OPTS" in
+			  nolock|*,nolock|nolock,*|*,nolock,*)
+			  	# no action
+				;;
+			  *)
+				start_nfs=yes
+				;;
+			esac
+
+			# However, Kerberos requires gssd, so start nfs-common anyway.
+			case "$OPTS" in
+			  sec=krb5|*,sec=krb5|sec=krb5,*|*,sec=krb5,*|sec=krb5i|*,sec=krb5i|sec=krb5i,*|*,sec=krb5i,*|sec=krb5p|*,sec=krb5p|sec=krb5p,*|*,sec=krb5p,*)
+
+			  	start_nfs=yes
+				;;
+			esac
+			;;
+		  nfs4)
+			# NFSv4 requires idmapd, so start nfs-common no matter what the options are.
+			start_nfs=yes
+			;;
+		  smbfs|cifs|coda|ncp|ncpfs|ocfs2|gfs)
+			;;
+		  *)
+			FSTYPE=
+			;;
+		esac
+		if [ "$FSTYPE" ]
+		then
+			case "$NETFS" in
+			  $FSTYPE|*,$FSTYPE|$FSTYPE,*|*,$FSTYPE,*)
+				;;
+			  *)
+				NETFS="$NETFS${NETFS:+,}$FSTYPE"
+				;;
+			esac
+		fi
+	done
+
+	exec 0<&9 9<&-
+}
+
+do_start() {
+	#
+	# Initialize nfs-common (which starts rpc.statd, rpc.gssd
+	# and/or rpc.idmapd, and loads the right kernel modules if
+	# applicable) if we use Kerberos and/or NFSv4 mounts.
+	#
+	if [ "$start_nfs" = yes ] && [ -x /etc/init.d/portmap ] && [ -x /etc/init.d/nfs-common ]
+	then
+		/etc/init.d/portmap start
+		/etc/init.d/nfs-common start
+	fi
+
+	pre_mountall
+	if [ "$NETFS" ]
+	then
+		mount -a -t$NETFS
+	fi
+	if [ "$NETDEV" ]; then
+		mount -a -O _netdev
+	fi
+	post_mountall
+}
+
+exit_unless_last_interface() {
+    grep "^[:space:]*auto" /etc/network/interfaces  | \
+	sed -e 's/[ \t]*auto[ \t]*//;s/[ \t]*$//;s/[ \t]/\n/g' | \
+	while read i; do
+	if [ `grep -c $i /etc/network/run/ifstate` -eq "0" ]; then
+	    msg="if-up.d/mountnfs[$IFACE]: waiting for interface $i before doing NFS mounts"
+	    log_warning_msg "$msg"
+	    # Can not pass this as a variable because of the while subshell
+	    mkdir /var/run/network/mountnfs_earlyexit 2> /dev/null
+	fi
+    done
+    if [ -d /var/run/network/mountnfs_earlyexit ]; then
+	rmdir /var/run/network/mountnfs_earlyexit 2>/dev/null
+	exit 0
+    fi
+}
+
+# Using 'no !=' instead of 'yes =' to make sure async nfs mounting is
+# the default even without a value in /etc/default/rcS
+set_env
+# Exit imediately and do not claim to wait for the last interface if
+# no network file systems are listed in /etc/fstab.
+if [ "$start_nfs" = "no" ] && [ ! "$NETFS" ] && [ ! "$NETDEV" ]; then
+  exit 0
+fi
+
+if [ no != "$ASYNCMOUNTNFS" ]; then
+    # Not for loopback!
+    [ "$IFACE" != "lo" ] || exit 0
+
+    # Lock around this otherwise insanity may occur
+    mkdir /var/run/network          2>/dev/null || true
+
+    # Wait until all auto interfaces are up before attemting to mount
+    # network file systems.
+    exit_unless_last_interface
+
+    if mkdir /var/run/network/mountnfs 2>/dev/null ; then
+	:
+    else
+	msg="if-up.d/mountnfs[$IFACE]: lock /var/run/network/mountnfs exist, not mounting"
+	log_failure_msg "$msg"
+	# Log if /usr/ is mounted
+	[ -x /usr/bin/logger ] && /usr/bin/logger -t "if-up.d/mountnfs[$IFACE]" "$msg"
+	exit 0
+    fi
+
+    on_exit() {
+        # Clean up lock when script exits, even if it is interrupted
+	rmdir /var/run/network/mountnfs 2>/dev/null || exit 0
+    }
+    trap on_exit EXIT # Enable emergency handler
+    do_start
+elif [ yes = "$FROMINITD" ] ; then
+    do_start
+fi
diff -ruN sysvinit-2.87dsf/initscripts/lib/init/bootclean.sh sysvinit/initscripts/lib/init/bootclean.sh
--- sysvinit-2.87dsf/initscripts/lib/init/bootclean.sh	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/lib/init/bootclean.sh	2011-07-26 02:05:43.387000850 +0900
@@ -0,0 +1,190 @@
+#!/bin/sh
+#
+# bootclean
+#
+# Clean /tmp.  Clean /var/run and /var/lock if not mounted as tmpfs
+#
+# DO NOT RUN AFTER S:55bootmisc.sh and do not run this script directly
+# in runlevel S. Instead write an initscript to call it.
+#
+
+. /lib/init/vars.sh
+
+. /lib/lsb/init-functions
+
+# Should be called outside verbose message block
+mkflagfile()
+{
+	# Prevent symlink attack  (See #264234.)
+	[ -L "$1" ] && log_warning_msg "bootclean: Deleting symbolic link '$1'."
+	rm -f "$1" || { log_failure_msg "bootclean: Failure deleting '$1'." ; return 1 ; }
+	# No user processes should be running, so no one should be able to introduce
+	# a symlink here.  As an extra precaution, set noclobber.
+	set -o noclobber
+	:> "$1" || { log_failure_msg "bootclean: Failure creating '$1'." ; return 1 ; }
+	return 0
+}
+
+clean_tmp() {
+	cd /tmp || { log_failure_msg "bootclean: Could not cd to /tmp." ; return 1 ; }
+
+	#
+	# Only clean out /tmp if it is world-writable. This ensures
+	# it really is a/the temp directory we're cleaning.
+	#
+	[ "$(find . -maxdepth 0 -perm -002)" = "." ] || return 0
+
+	if [ ! "$TMPTIME" ]
+	then
+		log_warning_msg "Using default TMPTIME 0."
+		TMPTIME=0
+	fi
+
+	[ "$VERBOSE" = no ] || log_action_begin_msg "Cleaning /tmp"
+
+	#
+	# Remove regardless of TMPTIME setting
+	#
+	rm -f .X*-lock
+
+	#
+	# Don't clean remaining files if TMPTIME is negative or 'infinite'
+	#
+	case "$TMPTIME" in
+	  -*|infinite|infinity)
+		[ "$VERBOSE" = no ] || log_action_end_msg 0 "skipped"
+		return 0
+		;;
+	esac
+
+	#
+	# Wipe /tmp, excluding system files, but including lost+found
+	#
+	# If TMPTIME is set to 0, we do not use any ctime expression
+	# at all, so we can also delete files with timestamps
+	# in the future!
+	#
+	if [ "$TMPTIME" = 0 ] 
+	then
+		TEXPR=""
+		DEXPR=""
+	else
+		TEXPR="-mtime +$TMPTIME -ctime +$TMPTIME -atime +$TMPTIME"
+		DEXPR="-mtime +$TMPTIME -ctime +$TMPTIME"
+	fi
+
+	EXCEPT='! -name .
+		! ( -path ./lost+found -uid 0 )
+		! ( -path ./quota.user -uid 0 )
+		! ( -path ./aquota.user -uid 0 )
+		! ( -path ./quota.group -uid 0 )
+		! ( -path ./aquota.group -uid 0 )
+		! ( -path ./.journal -uid 0 )
+		! ( -path ./.clean -uid 0 )
+		! ( -path './...security*' -uid 0 )'
+
+	mkflagfile /tmp/.clean || return 1
+
+	report_err()
+	{
+		if [ "$VERBOSE" = no ]
+		then
+			log_failure_msg "bootclean: Failure cleaning /tmp."
+		else
+			log_action_end_msg 1 "bootclean: Failure cleaning /tmp"
+		fi
+	}
+
+	#
+	# First remove all old files...
+	#
+	find . -depth -xdev $TEXPR $EXCEPT ! -type d -delete \
+		|| { report_err ; return 1 ; }
+
+	#
+	# ...and then all empty directories
+	#
+	find . -depth -xdev $DEXPR $EXCEPT -type d -empty -delete \
+		|| { report_err ; return 1 ; }
+
+	[ "$VERBOSE" = no ] || log_action_end_msg 0
+	return 0
+}
+
+clean_lock() {
+	if [ yes = "$RAMLOCK" ] ; then
+	    return 0
+	fi
+
+	cd /var/lock || { log_failure_msg "bootclean: Could not cd to /var/lock." ; return 1 ; }
+
+	[ "$VERBOSE" = no ] || log_action_begin_msg "Cleaning /var/lock"
+	report_err()
+	{
+		if [ "$VERBOSE" = no ]
+		then
+			log_failure_msg "bootclean: Failure cleaning /var/lock."
+		else
+			log_action_end_msg 1 "bootclean: Failure cleaning /var/lock"
+		fi
+	}
+	find . ! -type d -delete \
+		|| { report_err ; return 1 ; }
+	[ "$VERBOSE" = no ] || log_action_end_msg 0
+	mkflagfile /var/lock/.clean || return 1
+	return 0
+}
+
+clean_run() {
+	if [ yes = "$RAMRUN" ] ; then
+	    return 0
+	fi
+
+	cd /var/run || { log_action_end_msg 1 "bootclean: Could not cd to /var/run." ; return 1 ; }
+
+	[ "$VERBOSE" = no ] || log_action_begin_msg "Cleaning /var/run"
+	report_err()
+	{
+		if [ "$VERBOSE" = no ]
+		then
+			log_failure_msg "bootclean: Failure cleaning /var/run."
+		else
+			log_action_end_msg 1 "bootclean: Failure cleaning /var/run"
+		fi
+	}
+	find . ! -xtype d ! -name utmp ! -name innd.pid -delete \
+		|| { report_err ; return 1 ; }
+	[ "$VERBOSE" = no ] || log_action_end_msg 0
+	mkflagfile /var/run/.clean || return 1
+	return 0
+}
+
+which find >/dev/null 2>&1 || exit 1
+log_begin_msg "Cleaning up temporary files..."
+
+# If there are flag files that have not been created by root
+# then remove them
+for D in /tmp /var/run /var/lock
+do
+	if [ -f $D/.clean ]
+	then
+		which stat >/dev/null 2>&1 && cleanuid="$(stat -c %u $D/.clean)"
+		# Poor's man stat %u, since stat (and /usr) might not be
+		# available in some bootup stages
+		[ "$cleanuid" ] || cleanuid="$(find $D/.clean -printf %U)"
+		[ "$cleanuid" ] || { log_failure_msg "bootclean: Could not stat '$D/.clean'." ; exit 1 ; }
+		if [ "$cleanuid" -ne 0 ]
+		then
+			rm -f $D/.clean || { log_failure_msg "bootclean: Could not delete '$D/.clean'." ; exit 1 ; }
+		fi
+	fi
+done
+
+[ -f /tmp/.clean ] && [ -f /var/run/.clean ] && [ -f /var/lock/.clean ] && { log_end_msg 0 ; exit 0 ; }
+
+ES=0
+[ -d /tmp ] && ! [ -f /tmp/.clean ] && { clean_tmp || ES=1 ; }
+[ -d /var/run ] && ! [ -f /var/run/.clean ] && { clean_run || ES=1 ; }
+[ -d /var/lock ] && ! [ -f /var/lock/.clean ] && { clean_lock || ES=1 ; }
+log_end_msg $ES
+exit $ES
diff -ruN sysvinit-2.87dsf/initscripts/lib/init/mount-functions.sh sysvinit/initscripts/lib/init/mount-functions.sh
--- sysvinit-2.87dsf/initscripts/lib/init/mount-functions.sh	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/lib/init/mount-functions.sh	2011-07-26 02:05:43.387000850 +0900
@@ -0,0 +1,165 @@
+#
+# Functions used by several mount* scripts in initscripts package
+#
+# Sourcer must source /lib/lsb/init-functions.sh
+
+# $1: directory
+is_empty_dir() {
+	for FILE in $1/* $1/.*
+	do
+		case "$FILE" in
+		  "$1/.*") return 0 ;;
+		  "$1/*"|"$1/."|"$1/..") continue ;;
+		  *) return 1 ;;
+		esac
+	done
+	return 0
+}
+
+
+selinux_enabled () {
+	which selinuxenabled >/dev/null 2>&1 && selinuxenabled
+}
+
+
+# Called before mtab is writable to mount kernel and device file systems.
+# $1: file system type
+# $2: alternative file system type (or empty string if none)
+# $3: mount point
+# $4: mount device name
+# $5... : extra mount program options
+domount () {
+	MTPT="$3"
+	KERNEL="$(uname -s)"
+	# Figure out filesystem type
+	FSTYPE=
+	if [ "$1" = proc ]
+	then
+		case "$KERNEL" in
+			Linux|GNU) FSTYPE=proc ;;
+			*FreeBSD)  FSTYPE=linprocfs ;;
+			*)         FSTYPE=procfs ;;
+		esac
+	elif [ "$1" = tmpfs ]
+	then # always accept tmpfs, to mount /lib/init/rw before /proc
+		FSTYPE=$1
+	elif grep -E -qs "$1\$" /proc/filesystems
+	then
+		FSTYPE=$1
+	elif grep -E -qs "$2\$" /proc/filesystems
+	then
+		FSTYPE=$2
+	fi
+
+	if [ ! "$FSTYPE" ]
+	then
+		if [ "$2" ]
+		then
+			log_warning_msg "Filesystem types '$1' and '$2' are not supported. Skipping mount."
+		else
+			log_warning_msg "Filesystem type '$1' is not supported. Skipping mount."
+		fi
+		return
+	fi
+
+	# We give file system type as device name if not specified as
+	# an argument
+	if [ "$4" ] ; then
+	    DEVNAME=$4
+	else
+	    DEVNAME=$FSTYPE
+	fi
+
+	# Get the options from /etc/fstab.
+	OPTS=
+	if [ -f /etc/fstab ]
+	then
+		exec 9<&0 </etc/fstab
+
+		while read TAB_DEV TAB_MTPT TAB_FSTYPE TAB_OPTS TAB_REST
+		do
+			case "$TAB_DEV" in (""|\#*) continue ;; esac
+			[ "$MTPT" = "$TAB_MTPT" ] || continue
+			[ "$FSTYPE" = "$TAB_FSTYPE" ] || continue
+			case "$TAB_OPTS" in
+			  noauto|*,noauto|noauto,*|*,noauto,*)
+				exec 0<&9 9<&-
+				return
+				;;
+			  ?*)
+				OPTS="-o$TAB_OPTS"
+				;;
+			esac
+			break
+		done
+
+		exec 0<&9 9<&-
+	fi
+
+	if [ ! -d "$MTPT" ]
+	then
+		log_warning_msg "Mount point '$MTPT' does not exist. Skipping mount."
+		return
+	fi
+
+	if mountpoint -q "$MTPT"
+	then
+		return # Already mounted
+	fi
+
+	if [ "$VERBOSE" != "no" ]; then
+		is_empty_dir "$MTPT" >/dev/null 2>&1 || log_warning_msg "Files under mount point '$MTPT' will be hidden."
+	fi
+	mount -n -t $FSTYPE $5 $OPTS $DEVNAME $MTPT
+	if [ "$FSTYPE" = "tmpfs" -a -x /sbin/restorecon ]; then
+		/sbin/restorecon $MTPT
+	fi
+}
+
+#
+# Preserve /var/run and /var/lock mountpoints
+#
+pre_mountall ()
+{
+	# We may end up mounting something over top of /var, either directly
+	# or because /var is a symlink to something that's mounted.  So keep
+	# copies of the /var/run and /var/lock mounts elsewhere on the root
+	# filesystem so they can be moved back.
+	if [ yes = "$RAMRUN" ] ; then
+		mkdir /lib/init/rw/var.run
+		mount -n --bind /var/run /lib/init/rw/var.run
+	fi
+	if [ yes = "$RAMLOCK" ] ; then
+		mkdir /lib/init/rw/var.lock
+		mount -n --bind /var/lock /lib/init/rw/var.lock
+	fi
+}
+
+#
+# Restore /var/run and /var/lock mountpoints if something was mounted
+# as /var/.  Avoid mounting them back over themselves if nothing was
+# mounted as /var/ by checking if /var/run/ and /var/lock/ are still
+# mount points.  Enabling RAMRUN and RAMLOCK while listing /var/run or
+# /var/lock in /etc/fstab is not supported.
+#
+post_mountall ()
+{
+	if [ yes = "$RAMRUN" ] ; then
+		[ -d /var/run ] || mkdir /var/run
+		if mountpoint -q /var/run ; then
+			umount /lib/init/rw/var.run
+		else
+			mount -n --move /lib/init/rw/var.run /var/run
+		fi
+		rmdir /lib/init/rw/var.run
+	fi
+	if [ yes = "$RAMLOCK" ] ; then
+		[ -d /var/lock ] || mkdir /var/lock
+		if mountpoint -q /var/lock ; then
+			umount /lib/init/rw/var.lock
+		else
+			mount -n --move /lib/init/rw/var.lock /var/lock
+		fi
+		rmdir /lib/init/rw/var.lock
+	fi
+}
diff -ruN sysvinit-2.87dsf/initscripts/lib/init/splash-functions-base sysvinit/initscripts/lib/init/splash-functions-base
--- sysvinit-2.87dsf/initscripts/lib/init/splash-functions-base	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/lib/init/splash-functions-base	2011-07-26 02:05:43.387000850 +0900
@@ -0,0 +1,93 @@
+# This script contains hooks to allow init scripts to control
+# a splash program during boot and shutdown.
+#
+# To override these, provide a /lib/init/splash-functions scripts
+# with new functions (it is sourced at the end of this file)
+#
+# Note that scripts have a number of constraints:
+#  1) Should avoid using any binaries not found in the initramfs so that 
+#     the same hooks can be used there.
+#  2) This also means that bashisms can't be used.
+#  3) Scripts must work when running under "set -e".
+#  4) "local" should be used to avoid overwriting global variables.
+
+
+# Detects whether a splash is running
+splash_running() { return 1; }
+
+# Tells the splash to quit
+splash_stop() { return 0; }
+
+# Tells the splash to start if not already running
+splash_start() { return 1; }
+
+# Tells the splash the current boot/shutdown progress
+# $1 contains the progress as a percentage value between -100 and 100
+# Positive values indicate boot progress
+# Negative values indicate shutdown progress
+splash_progress()
+{
+	local progress tmp
+	progress="$1"
+
+	splash_running || return 0
+
+	# Sanity check step 1 - must match ^-[0-9]*$
+	tmp="$progress"
+
+	# Strip trailing numbers
+	while [ "${tmp%[0-9]}" != "$tmp" ]; do
+		tmp="${tmp%[0-9]}"
+	done
+
+	# Now "-" or no characters should remain
+	if [ -n "$tmp" ] && [ "$tmp" != "-" ]; then
+		return 1
+	fi
+
+	#  Sanity check step 2 - check for values >= -100 and <= 100
+	if [ "$progress" != "${progress#-}" ]; then
+		# Negative value
+		if [ "$progress" -lt -100 ]; then
+			return 1
+		fi
+	else
+		# Positive value
+		if [ "$progress" -gt 100 ]; then
+			return 1
+		fi
+	fi
+
+	# Sanity checks passed
+	custom_splash_progress "$progress" || return 1
+	return 0
+}
+
+# Customizations should replace this function instead of splash_progress above
+custom_splash_progress() { return 0; }
+
+
+# Tells the splash that a task which may take an unknown amount of
+# time has started (such as a fsck). This is useful to make sure the
+# splash doesn't time out and to give visual feedback to the user.
+splash_start_indefinite() { return 0; }
+
+# Tells the splash that an indefinite task is done
+splash_stop_indefinite() { return 0; }
+
+# Gets user input from a splash
+# $1 contains the text for the user prompt
+# $2 describes the type of input:
+#     regular  = regular input, e.g. a user name
+#     password = input which should not be echoed to screen, e.g. a password
+#     enter    = A "press enter to continue" type of prompt
+#
+# Returns 1 if no user input is possible
+# Should be called with an alternative non-splash input fallback:
+#   INPUT="$(splash_user_input "Enter password:" password)" || \
+#   INPUT="$(manual_method)"
+splash_user_input() { return 1; }
+
+# Allow these functions to be overridden with custom scripts.  This is
+# the official API hook.
+if [ -e /lib/init/splash-functions ] ; then . /lib/init/splash-functions ; fi
diff -ruN sysvinit-2.87dsf/initscripts/lib/init/usplash-fsck-functions.sh sysvinit/initscripts/lib/init/usplash-fsck-functions.sh
--- sysvinit-2.87dsf/initscripts/lib/init/usplash-fsck-functions.sh	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/lib/init/usplash-fsck-functions.sh	2011-07-26 02:05:43.387000850 +0900
@@ -0,0 +1,178 @@
+#
+# Functions for reporting fsck progress in usplash
+#
+# (C) 2008 Canonical Ltd.
+# Author: Martin Pitt <martin.pitt@ubuntu.com>
+#
+
+# convert a "pass cur max" progress triple from fsck to a progress percentage
+# based on calc_percent() from e2fsck
+fsck_progress_to_percent() {
+    if [ $1 = 1 ]; then
+        PERCENT=$(($2 * 70 / $3))
+    elif [ $1 = 2 ]; then
+        PERCENT=$(($2 * 20 / $3 + 70))
+    elif [ $1 = 3 ]; then
+        PERCENT=$(($2 * 2 / $3 + 90))
+    elif [ $1 = 4 ]; then
+        PERCENT=$(($2 * 3 / $3 + 92))
+    elif [ $1 = 5 ]; then
+        PERCENT=$(($2 * 5 / $3 + 95))
+    else
+        PERCENT=100
+    fi
+}
+
+# read current fsck status ($PASS, $CUR, $MAX) from file descriptor 4
+# this assumes that fsck was started in the background ($!)
+get_fsck_status()
+{
+        local a b c S
+
+        unset a
+        # only consider the last line
+        while true; do
+            PASS=$a
+            CUR=$b
+            MAX=$c
+            read a b c rest <&4
+            if [ -n "$PASS" ] && [ -z "$a" ]; then
+                break;
+            fi
+
+            # if we did not read anything, check if the process is still
+            # actually running, or just waiting to be reaped
+            if [ -z "$PASS" ] && [ -z "$a" ]; then
+                S=`ps -o state --no-headers -p $!` || break
+                [ "$S" != "Z" ] || break
+                # do not spin while waiting for fsck to start up
+                sleep 0.1
+            fi
+        done
+}
+
+# Set $NAME to a human readable description of which partitions are currently
+# being checked. Set $CLEAN if this is only a routine check on clean
+# partitions which can be skipped.
+get_checked_names ()
+{
+        local DEVS DUMP LABEL
+
+        FSCKPROCS=$(ps --no-headers -C 'fsck.ext2 fsck.ext3 fsck.ext4 fsck.ext4dev' -o pid,args | grep /dev)
+        DEVS=$(echo "$FSCKPROCS" | sed 's_^.*\(/dev/[^[:space:]]*\).*$_\1_')
+        FSCKPIDS=$(echo "$FSCKPROCS" | sed 's_^[[:space:]]*\([[:digit:]]\+\).*$_\1_')
+
+        if [ -z "$DEVS" ]; then
+            unset NAME
+            return 0
+        fi
+
+        CLEAN=1
+        unset NAME
+        for DEV in $DEVS; do
+            DUMP=$(dumpe2fs -h $DEV)
+            if ! echo "$DUMP" | grep -q 'state:[[:space:]]*clean$'; then
+                unset CLEAN
+            fi
+
+            LABEL=$(blkid $DEV | sed -rn '/LABEL="([^"]+)"/ { s/^.*LABEL="//; s/".*$//; p }')
+            [ -z "$NAME" ] || NAME="$NAME, "
+            if [ -n "$LABEL" ]; then
+                NAME="$NAME$LABEL ($DEV)"
+            else
+                NAME="$NAME$DEV"
+            fi
+        done
+}
+
+# Return true if usplash is active
+usplash_running() {
+    if pidof usplash ; then
+	return 0
+    else
+	return 1
+    fi
+}
+
+# Read fsck progress from file $1 and display progress in usplash.
+usplash_progress() {
+        exec 4<$1
+        unset CANCEL
+        ESCAPE=`/bin/echo -ne "\x1B"`
+        FIRST=1
+        PREVPERCENT=0
+
+        while true; do
+            sleep 0.5
+            get_fsck_status
+            [ -n "$PASS" ] || break
+
+            fsck_progress_to_percent "$PASS" "$CUR" "$MAX"
+
+            # check if fsck advanced to the next drive
+            if [ "$PREVPERCENT" -gt "$PERCENT" ]; then
+                if [ -n "$CANCEL" ]; then
+                    usplash_write "STATUS skip                                                        "
+                else
+                    usplash_write "STATUS                                                             "
+                fi
+                FIRST=1
+            fi
+            PREVPERCENT=$PERCENT
+
+            # lazy initialization of output and progress report on the first
+            # progress line that we receive; this avoids starting the output
+            # for clean or non-ext[234] partitions
+            if [ -n "$FIRST" ]; then
+                usplash_write "TIMEOUT 0"
+
+                # show which device is being checked
+                get_checked_names
+                [ -n "$NAME" ] || break
+
+                usplash_write "VERBOSE on"
+                if [ "$CLEAN" ]; then
+                    usplash_write "TEXT Routine check of drives: $NAME..."
+                    usplash_write "TEXT Press ESC to skip"
+                else
+                    usplash_write "TEXT Unclean shutdown, checking drives:"
+                    usplash_write "TEXT $NAME..."
+                fi
+
+                unset FIRST
+            fi
+
+            usplash_write "STATUS $PERCENT% (stage $PASS/5, $CUR/$MAX)                       "
+            echo "Checking drive $NAME: $PERCENT% (stage $PASS/5, $CUR/$MAX)" >/dev/console
+
+            # ESC interrupts check for clean drives
+            if [ -n "$CLEAN" ]; then
+                if FAIL_NO_USPLASH=1 usplash_write "INPUTCHAR"; then
+                    read ch < /dev/.initramfs/usplash_outfifo
+                    if [ "$ch" = "$ESCAPE" ]; then
+                        kill $FSCKPIDS
+                        CANCEL=1
+                        continue # there might be more drives, so do not break
+                    fi
+                fi
+            fi
+        done
+
+        if [ -n "$CANCEL" ]; then
+            usplash_write "STATUS skip                                                        "
+        else
+            usplash_write "STATUS                                                             "
+        fi
+        usplash_write "VERBOSE default"
+        usplash_write "TEXT Drive checks finished."
+        usplash_write "TIMEOUT 15"
+        wait %1 # to collect fsck's exit code
+        EXITCODE=$?
+        [ -n "$CANCEL" ] && FSCKCODE=0 || FSCKCODE=$EXITCODE
+        if [ "$FSCKCODE" -gt 1 ]; then
+            # non-correctable failure which requires sulogin: quit usplash and
+            # restore stdin/out/err
+            usplash_write "QUIT"
+            exec </dev/console >/dev/console 2>/dev/console
+        fi
+}
diff -ruN sysvinit-2.87dsf/initscripts/lib/init/vars.sh sysvinit/initscripts/lib/init/vars.sh
--- sysvinit-2.87dsf/initscripts/lib/init/vars.sh	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/lib/init/vars.sh	2011-07-26 02:05:43.387000850 +0900
@@ -0,0 +1,26 @@
+#
+# Set rcS vars
+#
+
+[ -f /etc/default/rcS ] && . /etc/default/rcS || true
+
+# check for bootoption 'noswap' and do not activate swap
+# partitions/files when it is set.
+## Work around Busybox grep not supporting -w switch
+#if [ -r /proc/cmdline ] && grep -qw 'noswap' /proc/cmdline ; then
+if [ -r /proc/cmdline ] && egrep -q '(^|\W)noswap($|\W)' /proc/cmdline ; then
+    NOSWAP=yes
+else
+    NOSWAP=no
+fi
+
+# Accept the same 'quiet' option as the kernel
+## Work around Busybox grep not supporting -w switch
+#if [ ! -e /proc/cmdline ] || egrep -qw 'quiet' /proc/cmdline ; then
+if [ ! -e /proc/cmdline ] || egrep -q '(^|\W)quiet($|\W)' /proc/cmdline ; then
+    VERBOSE="no"
+fi
+
+# But allow both rcS and the kernel options 'quiet' to be overrided
+# when INIT_VERBOSE=yes is used as well.
+[ "$INIT_VERBOSE" ] && VERBOSE="$INIT_VERBOSE" || true
diff -ruN sysvinit-2.87dsf/initscripts/Makefile sysvinit/initscripts/Makefile
--- sysvinit-2.87dsf/initscripts/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/Makefile	2011-07-26 02:05:43.385000852 +0900
@@ -0,0 +1,44 @@
+DESTDIR =
+sysconfdir = /etc
+prefix     = /usr
+docdir     = $(prefix)/share/doc/initscripts
+sbindir    = /sbin
+
+INSTALL      = install -m755
+INSTALL_DATA = install -m644
+
+all:
+
+install:
+	$(INSTALL) -d $(DESTDIR)/lib/init/rw/.
+	$(INSTALL) -d $(DESTDIR)/var/lib/initscripts/.
+	$(INSTALL) -d $(DESTDIR)/var/lib/urandom/.
+	$(INSTALL) -d $(DESTDIR)/var/log/fsck/.
+	$(INSTALL) -d $(DESTDIR)$(docdir)/.
+	$(INSTALL_DATA) doc/* $(DESTDIR)$(docdir)
+	$(INSTALL) -d $(DESTDIR)/usr/share/initscripts
+	cp -afv share/* $(DESTDIR)/usr/share/initscripts
+	find $(DESTDIR)/usr/share/initscripts -type d -name .svn -print0 |xargs -r0 rm -r
+
+	$(INSTALL) -d $(DESTDIR)$(sysconfdir)/.
+	$(INSTALL) -d $(DESTDIR)$(sysconfdir)/default
+	cp -afv etc/* $(DESTDIR)$(sysconfdir)
+	find $(DESTDIR)$(sysconfdir) -type d -name .svn -print0 |xargs -r0 rm -r
+
+	cp -afv lib/* $(DESTDIR)/lib
+	find $(DESTDIR)/lib -type d -name .svn  -print0 |xargs -r0 rm -r
+	chmod 755 $(DESTDIR)$(sysconfdir)/init.d/[a-z]*
+	chmod 755 $(DESTDIR)$(sysconfdir)/network/if-up.d/[a-z]*
+	chmod 644 $(DESTDIR)/lib/init/*.sh
+	chmod 644 $(DESTDIR)$(sysconfdir)/init.d/skeleton
+	chmod -R g-w $(DESTDIR)
+
+	$(INSTALL) -d $(DESTDIR)$(sbindir)/.
+	$(INSTALL) sbin/fsck.nfs $(DESTDIR)$(sbindir)/fsck.nfs
+
+	$(INSTALL) -d $(DESTDIR)/usr/share/man/man8
+	$(INSTALL_DATA) man/fsck.nfs.8 \
+		$(DESTDIR)/usr/share/man/man8/fsck.nfs.8
+
+	$(INSTALL) -d $(DESTDIR)/usr/share/man/man5
+	$(INSTALL_DATA) man/*.5 $(DESTDIR)/usr/share/man/man5/.
diff -ruN sysvinit-2.87dsf/initscripts/man/fsck.nfs.8 sysvinit/initscripts/man/fsck.nfs.8
--- sysvinit-2.87dsf/initscripts/man/fsck.nfs.8	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/man/fsck.nfs.8	2011-07-26 02:05:43.385000852 +0900
@@ -0,0 +1,16 @@
+.TH FSCK.NFS 8 "May 2004" "Initscripts"
+.SH NAME
+fsck.nfs \- Dummy fsck.nfs script that always returns success.
+.SH SYNOPSIS
+.B fsck.nfs
+.SH DESCRIPTION
+Debian GNU/Linux need this for when the root file system is on NFS: there is
+no way to find out if root is NFS mounted and we really want to do a
+"fsck -a /".
+.SH EXIT CODE
+The exit code returned by
+.B mount.nfs
+is always zero, meaning successful completion.
+.SH SEE ALSO
+.BR fsck (8),
+.BR fstab (5).
diff -ruN sysvinit-2.87dsf/initscripts/man/halt.5 sysvinit/initscripts/man/halt.5
--- sysvinit-2.87dsf/initscripts/man/halt.5	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/man/halt.5	2011-07-26 02:05:43.385000852 +0900
@@ -0,0 +1,49 @@
+.TH halt 5 "16 Jan 2007" "" "File Formats"
+.SH NAME
+halt \- variables that affect the behavior of the shutdown scripts
+.SH DESCRIPTION
+The
+.I /etc/default/halt
+file contains variable settings in POSIX format:
+.IP "" .5i
+VAR=VAL
+.PP
+Only one assignment is allowed per line.
+Comments (starting with '#') are also allowed.
+
+.SH OPTIONS
+The following variables can be set.
+
+.IP \fBHALT\fP
+If set to 
+.B poweroff
+the system will be powered down after it has been
+brought down. This is the default.
+.br
+If set to 
+.B halt 
+the system will only be halted after it has been brought
+down. What exactly this means depends on your hardware.
+
+.IP \fBNETDOWN\fB
+Setting this to
+.B no
+prevents shutdown from shutting down the network intefaces.
+This is necessary to use Wake-On-Lan.
+Setting it to
+.B yes
+causes shutdown to also bring down the network interfaces (and
+thus prevent the machine from being woken up remotely).
+
+.SH SEE ALSO
+.BR halt "(8), " shutdown "(8)."
+
+.SH AUTHOR
+\fBCasper Gielen\fR <\&casper@gielen.name\&>
+
+.SH "COPYRIGHT"
+This manual page is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
+.PP
+This manual page is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
+.PP
+You should have received a copy of the GNU General Public License along with this manual page; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111\-1307 USA
diff -ruN sysvinit-2.87dsf/initscripts/man/rcS.5 sysvinit/initscripts/man/rcS.5
--- sysvinit-2.87dsf/initscripts/man/rcS.5	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/man/rcS.5	2011-07-26 02:05:43.385000852 +0900
@@ -0,0 +1,128 @@
+.TH rcS 5 "16 Jan 2006" "" "Debian Administrator's Manual"
+.SH NAME
+rcS \- variables that affect the behavior of boot scripts
+.SH DESCRIPTION
+The
+.I /etc/default/rcS
+file contains variable settings in POSIX format:
+.IP "" .5i
+VAR=VAL
+.PP
+Only one assignment is allowed per line.
+Comments (starting with '#') are also allowed.
+
+.SH OPTIONS
+The following variables can be set.
+For the default values please see \fI/usr/share/initscripts/default.rcS\fP.
+
+.IP \fBTMPTIME\fP
+On boot the files in /tmp will be deleted if their modification time
+is more than TMPTIME days ago.
+A value of 0 means that files are removed regardless of age.
+If you don't want the system to clean /tmp
+then set TMPTIME to a negative value (e.g., \-1)
+or to the word \fIinfinite\fP.
+
+.IP \fBSULOGIN\fB
+Setting this to
+.B yes
+causes init to spawn a
+.B sulogin
+on the console early in the boot process.
+If the administrator does not login
+then the sulogin session will time out
+after 30 seconds and the boot process will continue.
+
+.IP \fBDELAYLOGIN\fB
+Normally the system will not let non-root users log in
+until the boot process is complete
+and the system has finished switching
+to the default runlevel (usually level 2).
+However, in theory it is safe to log in a bit earlier,
+namely, as soon as \fBinetd\fP has started.
+Setting the variable to \fBno\fP allows earlier login;
+setting the variable to \fByes\fP prevents it.
+
+Some details:
+The \fBDELAYLOGIN\fP variable controls whether or not the
+file \fI/var/lib/initscripts/nologin\fP is created during
+the boot process and deleted at the end of it.
+\fI/etc/nologin\fP is normally a symbolic link to the latter location,
+and the \fBlogin\fP(1) program refuses to allow non-root logins so long
+as (the target of) \fI/etc/nologin\fP exists.
+If you set the variable to \fBno\fP then it is advisable to ensure
+that \fI/var/lib/initscripts/nologin\fP does not exist.
+
+.IP \fBUTC\fP
+This is used to govern how the hardware real time clock is interpreted
+when it is read (e.g., at boot time, for the purpose of setting the
+system clock) and when it is written (e.g., at shutdown).
+If this option is set to \fBno\fP
+then the system clock is assumed to be set to local time.
+If the option is set to \fByes\fP
+then the system clock is assumed to be set to something approximating
+Coordinated Universal Time (UTC).
+(POSIX systems keep a variant of UTC, without leap seconds.)
+
+On contemporary Debian systems
+(although change has been requested at
+\fIhttp://bugs.debian.org/346342\fP),
+if UTC is set to \fBno\fP then \fI/usr/share/zoneinfo\fP
+must be readable early in the boot process.
+If you want to keep \fI/usr\fP on a separate filesystem then
+you must still ensure that the target of \fI/etc/localtime\fP
+points to the correct zone information file for the time zone
+of the time kept in your hardware real time clock.
+
+.IP \fBVERBOSE\fP
+Setting this option to \fBno\fP (in lower case) will make the boot process
+a bit less verbose.
+Setting this option to \fByes\fP will make the boot process
+a bit more verbose.
+
+.IP \fBFSCKFIX\fP
+When the root and all other file systems are checked,
+.B fsck
+is invoked with the \fB\-a\fP option
+which means "autorepair".
+If there are major inconsistencies
+then the fsck process will bail out.
+The system will print a message
+asking the administrator to repair the file system manually
+and will present a root shell prompt
+(actually a \fIsulogin\fP prompt)
+on the console.
+Setting this option to \fByes\fP causes the fsck commands
+to be run with the \fB\-y\fP option instead of the \fB\-a\fP option.
+This will tell fsck always to repair the file systems
+without asking for permission.
+
+.IP \fBRAMRUN\fP
+Make /var/run/ available as a ram file system (tmpfs).  Will also disable
+cleaning of /var/run/ during boot.  Set to 'yes' to enable, to 'no' to disable.
+The size of the tmpfs can be controlled using TMPFS_SIZE and RUN_SIZE in
+/etc/default/tmpfs.  Because of this, packages can not expect directories in /var/run
+to exist after boot.  Packages expecting this are buggy and need to be fixed.
+
+.IP \fBRAMLOCK\fP
+Make /var/lock/ available as a ram file system (tmpfs).  Will also disable
+cleaning of /var/lock/ during boot.  Set to 'yes' to enable, to 'no' to disable.
+The size of the tmpfs can be controlled using TMPFS_SIZE and LOCK_SIZE in
+/etc/default/tmpfs.  Because of this, packages can not expect directories in /var/lock
+to exist after boot.  Packages expecting this are buggy and need to be fixed.
+
+.IP \fBASYNCMOUNTNFS\fP
+Set this to 'no' to disable asynchronous mounting of network drives
+when the network interfaces are mounted, and instead do it only once when
+the machine boot.  The default is 'yes'.  It is useful to disable this
+on machines with the root file system in NFS until ifup from ifupdown work
+properly in such setup.
+
+.SH NOTE
+The \fBEDITMOTD\fP variable is no longer used.
+
+.SH AUTHOR
+Miquel van Smoorenburg <miquels@cistron.nl>
+
+.SH SEE ALSO
+.BR inetd "(8), " init "(8), " inittab "(5), " login "(1)."
diff -ruN sysvinit-2.87dsf/initscripts/sbin/fsck.nfs sysvinit/initscripts/sbin/fsck.nfs
--- sysvinit-2.87dsf/initscripts/sbin/fsck.nfs	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/sbin/fsck.nfs	2011-07-26 02:05:43.385000852 +0900
@@ -0,0 +1,21 @@
+#! /bin/sh
+#
+# fsck.nfs
+#
+# Dummy fsck.nfs file that always returns success. We
+# need this for when the root file system is on NFS:
+# there is no way to find out if root is NFS mounted
+# and we really want to do a "fsck -a /".
+#
+
+while :
+do
+	case "$1" in
+		-*) shift ;;
+		*) break ;;
+	esac
+done
+
+echo "$1: NFS file system."
+
+exit 0
diff -ruN sysvinit-2.87dsf/initscripts/share/default.rcS sysvinit/initscripts/share/default.rcS
--- sysvinit-2.87dsf/initscripts/share/default.rcS	1970-01-01 09:00:00.000000000 +0900
+++ sysvinit/initscripts/share/default.rcS	2011-07-26 02:05:43.385000852 +0900
@@ -0,0 +1,17 @@
+#
+# /etc/default/rcS
+#
+# Default settings for the scripts in /etc/rcS.d/
+#
+# For information about these variables see the rcS(5) manual page.
+#
+# This file belongs to the "initscripts" package.
+
+TMPTIME=0
+SULOGIN=no
+DELAYLOGIN=no
+UTC=yes
+VERBOSE=no
+FSCKFIX=no
+RAMRUN=no
+RAMLOCK=no
